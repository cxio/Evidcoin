# 转换指令

本类指令将数据转换为不同的*类型*和*值*。注意不只是类型的变化，底层的值也可能有改变。

> **设计：**
> 考虑安全性，不提供转换到脚本类型（`Script`）。
> 基本类型之间可互为转换，与复合类型之间仅部分可互为转换。


## 定义

指令码区间：`[67-79]`，13个。

```go
码值    指令字      说明
-----------------------------------------------------------
67      BOOL        转为布尔值：Bool
        // 实参：
        // - 空值：     nil => false
        // - 字节：     0   => false
        // - 符文：     0   => false
        // - 整数：     0   => false
        // - 大整数：   0   => false
        // - 浮点数：   x <= math.SmallestNonzeroFloat64 => false
        // - 字符串：   ""  => false
        // 以上非转换到假值的，即为真。如 1 => true
        // 提示：
        // 测试字典或切片是否非空："SIZE BOOL"。

68      BYTE        转为字节：Byte
        // 实参：
        // - 空值：     nil => 0
        // - 布尔值：   false => 0, true => 1
        // - 符文：     Unicode码值小于256的正常转换，否则出错
        // - 整数：     小于256的值正常转换，否则出错
        // - 大整数：   同上规则
        // - 浮点数：   取整，小于256的值可转换，否则出错
        // 注：
        // 不支持和字符串之间的转换。

69      RUNE        转为符文：Rune
        // 实参：
        // - 空值：     nil => 0
        // - 布尔值：   false => 0, true => 1
        // - 字节：     直接类型转换，值不变
        // - 整数：     不大于 0x10FFFF 时正常转换，否则出错
        // - 大整数：   同上规则
        // - 浮点数：   先取整，同上整数转换规则。
        // 注：
        // 不支持和字符串之间的转换。

70      INT         转为整数：Int
        // 实参：
        // - 空值：     nil => 0
        // - 布尔值：   false => 0, true => 1
        // - 字节：     简单类型转换，值不变
        // - 符文：     简单类型转换，值不变
        // - 大整数：   不大于 1<<63-1 的值正常转换，否则出错
        // - 浮点数：   截断小数部分，同上规则转换
        //
        // 便捷支持：
        // - 时间：     提取Unix时间戳（毫秒数）。
        // - 字符串：   支持Golang合法的整数表示：
        //              普通十进制
        //              0b|0B 二进制
        //              0o|0O 八进制
        //              0x|0X 十六进制
        //              数字之间支持单下划线友好分隔。
        // 注：
        // 字符串按字面意义理解（strconv规则）。

71      BIGINT      转为大整数：BigInt
        // 实参：
        // - 空值：     nil => BigInt(0)
        // - 布尔值：   false => 0, true => 1
        // - 字节：     简单类型转换，值不变
        // - 符文：     简单类型转换，值不变
        // - 整数：     简单类型转换，值不变
        //
        // 便捷支持：
        // - 字节序列： 按大端序转换（math/big）

72      FLOAT       转为浮点数：Float
        // 实参：
        // - 空值：     nil => 0.0
        // - 布尔值：   false => 0.0, true => 1.0
        // - 字节：     简单类型整数
        // - 符文：     简单类型整数
        // - 整数：     简单类型转换
        //
        // 便捷支持：
        // - 字符串：   合法的浮点数或科学记数法表示。

73      STRING(1){} 转为字符串：String
        // 附参：进制或格式标识。
        // 2 ~ 36
        // 进制数，适用于整数类型：
        // 如 STRING[16]，转换为16进制字符串表示。注：方括号包围。
        //
        // b, e, E, f, g, G, x, X
        // 浮点格式，适用于浮点数：
        // 如 STRING{E}，转换为带指数的字符串表示。注：花括号包围。
        //
        // 实参：
        // - 空值：     nil => ""
        // - 布尔值：   true => "true"; false => "false"
        // - 字节：     视为UTF-8编码字节，显示合法字符或16进制表示
        // - 符文：     视为Unicode码点值，显示合法字符或 \uhhhh|\Uhhhhhhhh 形式
        // - 整数：     由附参进制标识转换（strconv）
        // - 大整数：   由附参进制标识转换
        // - 浮点数：   由附参格式标识转换
        //
        // 便捷支持：
        // - 字节序列： 视为UTF-8编码的字节序列，显示结果
        // - 符文序列： 自动UTF-8编码（[]rune => string）

74      BYTES       转为字节序列：Bytes
        // 实参：
        // - 空值：     nil => []byte（空切片）
        // - 符文：     按UTF-8编码转换
        // - 整数：     按大端序转换，固定为8字节长
        // - 大整数：   按大端序转换，长度不定
        //
        // 便捷支持：
        // - 字符串：   即字符串按UTF-8编码
        // - 符文序列： 同上按UTF-8编码
        // - 脚本：     克隆源字节序列，类型转换
        // 注：
        // 考虑安全性，不支持反向的字节序列转脚本。

75      RUNES       转为符文序列：[]Rune
        // 特例：转为符文切片可方便某些处理。
        // 实参：
        // - 空值：     nil => []rune（空切片）
        // - 符文：     封装为一个符文的切片
        // - 字符串：   视为UTF-8解码为 []rune
        // - 字节序列： 视为UTF-8解码，无效码解为\uFFFD

76      TIME        转为时间对象：Time
        // 实参：
        // - 整数：     视为UNIX时间戳（毫秒数）
        // - 字符串：   需为 RFC3339 的标准格式
        // 例：
        // {1608883593536} TIME
        // 即 DATE{2020-12-25T08:06:33.536Z}
        // 例：
        // "2020-12-25T08:06:33.536+08:00" TIME
        // 即 DATE{2020-12-25T08:06:33.536+08:00}

77      REGEXP      转为正则表达式：RegExp
        // 即用实参值构造一个正则表达式对象。
        // 实参：字符串。
        // 仅支持从字符串转换，且字符串需形式合法。

78      DICT        构造字典：Dict（map[string]any）
        // 实参1：键序列（[]string）
        // 实参2：值序列（[]any）
        // 两个实参序列的成员按顺序对应创建一个字典：
        // - 键序列大于值序列时，不足部分为nil值。
        // - 键序列小于值序列时，多出的部分被忽略。
        // 例：
        // {"one", "two" "123"}
        // {100} {200} NIL {1.0}
        // DICT
        // 创建为：{
        //      "one": 100,
        //      "two": 200,
        //      "123": <nil>,   // 多余的 1.0 被忽略
        // }
        //
        // 设计：
        // 字典不是栈脚本的基础类型，因此不支持通过值指令创建。、
        // 但作为一个有效的工具，在此简单支持。

79      ANYS(1){}   切片间转换（[]any <=> []T）
        // 具体类型的切片转换为 []any，或反之。
        // 附参：转换标识。
        // 实参：目标切片或一个nil。
        // 标识：
        // => []any
        // 0:   NIL|[]xxx   => []any
        // []any =>
        // 1|2  NIL|[]any   => []Bool
        // 3:   NIL|[]any   => []Byte   // 同 Bytes
        // 4:   NIL|[]any   => []Rune
        // 5:   NIL|[]any   => []Int
        // 6:   NIL|[]any   => []*big.Int
        // 7:   NIL|[]any   => []Float
        // 8|9: NIL|[]any   => []String
        // 提示：
        // 一个NIL可以转换为任意一种空切片。
        // 一个空的any切片可以转为任意一种具体类型的空切片。
        // 友好：
        // 除零外，标识值实际上是该类型值指令的码值。
        // 支持用花括号包围成员类型名表达标识。
        // 例：
        // NIL ANYS     // 创建一个Any空切片。
        // {1,3,5} ANYS // []Int => []any
        // 例：
        // "AB" "XY" SHIFT[2] ANYS[8]       // []any => []String
        // "AB" "XY" SHIFT[2] ANYS{String}  // []any => []String
        // 提示：
        // 压入栈的每个成员都为any类型。
        // 例：
        // {0} NIL TRUE SHIFT[3] ANYS{Bool}
        // => [false, false, true]
        // 三个成员会自动转为布尔类型。
        //
        // 注记：
        // DICT的成员为any，因此有时需要把具体类型的值集转为[]any。
```
