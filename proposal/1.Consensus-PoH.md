# Consensus: Proof of Historical (PoH)（共识：历史证明）

> **Design Proposal** — 本文档描述 Evidcoin 的共识机制，
> 涵盖历史证明（PoH）算法、铸凭哈希计算、择优池协同、区块铸造流程、分叉解决、引导启动流程与端点约定。

## 1. Overview（概述）

Evidcoin 采用 **历史证明（PoH）** 作为其共识机制。不同于需要暴力哈希计算的工作量证明（PoW），
或将影响力绑定在财富上的权益证明（PoS），PoH 将铸造资格建立在 **历史交易 ID** 之上——该数据
可公开验证、在确认后不可变更，并且不依赖任何一方的资金持有情况。

核心属性：

| Property | Description |
|----------|-------------|
| **Fairness** | 每个已确认的交易 ID 权重相同；财富不会放大影响力。 |
| **Determinism** | 交易 ID 一旦被纳入区块即固定，作为既成事实而永远无法更改。 |
| **Accessibility** | 提高铸造概率的唯一方式是发起更多交易，这会产生手续费并奖励矿工——形成正向回馈。 |
| **Anti-shaping** | 多项对策防止攻击者通过构造交易数据来引导选择结果（见 §2）。 |

## 2. Minting Hash Computation（铸凭哈希计算）

### 2.1 Terminology（术语）

| Term | Definition |
|------|------------|
| **Minting Transaction** | 参与铸造竞争的历史交易，其可选区块范围为 `[Height-80000, Height-25]`（约 11 个月）。 |
| **Minter** | 花费铸造交易首笔输入的地址（即发送方，而非接收方）。使用已花费地址可避免冷挖矿动机。 |
| **Reference Block** | 高度为 `Height - 9` 的区块，其铸凭哈希与 UTXO 指纹参与计算。 |
| **UTXO Fingerprint** | 表示某个区块的交易应用后，全链 UTXO 集状态的摘要。 |

### 2.2 Anti-Shaping Measures（防塑造措施）

哈希塑造是一种攻击方式，攻击者向哈希输入中注入任意数据以偏向目标输出。PoH 通过精心选择因子来防御：

1. **尾部排除** — 排除区块 `[-1, -24]` 的交易，因为其创建者在创建时已知评参区块参数，可能塑造交易 ID。
2. **区块 ID 排除** — 排除评参区块自身的 ID，因为铸造者可通过 Coinbase 数据与交易排序进行操控。
3. **更深区块的 UTXO 指纹** — UTXO 指纹取自 `Height - 24` 区块（而非评参区块本身），因为在 UTXO 状态确定时还不知道评参区块的铸造者，使塑造指纹不可行，除非先预测铸造者。
4. **签名致盲** — 哈希输入在最终哈希前由铸造者私钥签名，攻击者若无私钥则无法预测任意铸凭交易的铸凭哈希。

### 2.3 Algorithm（算法）

```go
// MintingHash 计算铸凭哈希。
// txID:           铸凭交易 ID
// refMintHash:    评参区块（Height-9）的铸凭哈希
// utxoFP:         第 Height-24 区块的 UTXO 指纹
// blockTimestamp: 当前区块时间戳（由公式计算，非本地时钟）
// privateKey:     铸造者的私钥
func MintingHash(txID Hash512, refMintHash Hash512, utxoFP Hash512,
    blockTimestamp int64, privateKey PrivateKey) Hash512 {

    // 阶段一：组装源数据并哈希
    source := concat(txID, refMintHash, utxoFP, encodeInt64(blockTimestamp))
    hashData := SHA512(source)

    // 阶段二：用铸造者私钥签名（结果对外不可预测）
    signData := Sign(privateKey, hashData)

    // 阶段三：对签名结果取哈希，得到铸凭哈希
    return SHA512(signData)
}
```

**Selection criterion**：铸凭哈希按字节序列比较；**最小**值获胜。

## 3. Best Pool Mechanism（择优池机制）

### 3.1 Structure（结构）

Best Pool 是针对某个评参区块的铸造候选者有序缓冲区。每个节点维护一组池——每个即将成为评参区块的高度对应一个池。

```go
const BestPoolCapacity = 20

// BestPool 择优池：按铸凭哈希升序排列的铸造候选者集合。
type BestPool struct {
    RefHeight   int             // 对应的评参区块高度
    Candidates  [BestPoolCapacity]MintCandidate  // 按铸凭哈希升序排列
    Size        int             // 当前候选者数量
}

// MintCandidate 择优凭证：铸造候选者的证明信息。
type MintCandidate struct {
    TxYear    int       // 交易所在年度
    TxID      Hash512   // 铸凭交易 ID
    MinterPub PublicKey // 铸造者公钥（首笔输入的接收者）
    SignData  []byte    // 铸造者对铸凭哈希源数据的签名
    MintHash  Hash512   // 铸凭哈希（由 SignData 计算）
}
```

### 3.2 Insertion Rule（插入规则）

当新的铸造交易证明到达：

1. 计算其铸凭哈希。
2. 若池未满，按序插入并转播。
3. 若池已满，与最差（最大）条目比较；若更优则替换并按序插入并转播，否则静默丢弃。

### 3.3 Pool Lifecycle（池生命周期）

Best Pool 会随评参区块向 `-9` 位置演进而经历三阶段：

| Phase | Block Position | Duration | Activity |
|-------|---------------|----------|----------|
| **Broadcast & Collect** | 从创建到 `-7` | 6 个出块周期（约 36 分钟） | 节点计算铸凭哈希、广播证明并填充池；节点之间交换池状态以优化成员。 |
| **Sync & Optimize** | `-7` 到 `-9` | 2 个出块周期（约 12 分钟） | 停止池更新。授权节点在网络中同步池。 |
| **Locked** | 到达 `-9` | — | 池定稿，锚定评参区块的当前新块的铸造候选者确定。 |

### 3.4 Sync Protocol（同步协议）

#### Authorized Nodes（授权节点）

仅 Best Pool 中 **后 15 名**（排名 6–20）的候选者可发起同步。这基于“利益无关”原则：能排前几名的迟到者有动机把自己加入择优池，从而影响择优池的确定性，而只能低排名的迟到者没有这种动机。每个授权节点 **仅能** 同步一次。

> **注：**
> 择优池的确定性由共约完成，没有特别的约束算法。
> 这种授权设计就是为*保护择优池确定性*的一个低成本的机制。

#### Sync Process（同步流程）

1. 授权节点对其当前 Best Pool（称为 **Sync Pool**）签名并广播。
2. 接收节点创建 **Merge Pool** 并验证收到的 Sync Pool：
   - 签名者必须存在于接收者自身 Best Pool *或* Merge Pool 中（友好刚刚上线的节点）。
   - 签名者必须位于其发布的 Sync Pool 的后 15 名。
3. 验证通过后将条目并入 Merge Pool。
4. 同步阶段结束时，Merge Pool 替换该评参区块的 Best Pool。

### 3.5 Minter Legitimacy Verification（铸造者合法性验证）

验证铸造候选者合法性：

0. 首先核实交易ID的合法性。**注**：区块头链为验证终点（每个客户端都持有此信息）。
1. 根据交易ID检索其交易头信息、输入段信息（首领输入+剩余输入段哈希）和输出段根哈希。
2. 根据上面的信息验证交易ID是否匹配（**注**：从外部检索的交易ID需要核实）。
3. 根据首领输入（年度+交易ID+输出序位）检索其来源输出项数据（含公钥地址），以及哈希认证路径（类默克尔路径）。
4. 根据上面的信息验证首领输入的交易ID合法。
5. 核验首领输入数据里的接收者公钥哈希是否匹配择优凭证中的公钥？
6. 根据公钥验证择优凭证里的签名（以及铸凭哈希）。

## 4. Block Minting Workflow（区块铸造流程）

### 4.1 Block Time（出块时间）

出块时间 **固定为 6 分钟**。时间戳不存储在区块头中，而是按确定性规则计算：

```go
const BlockInterval = 6 * time.Minute

// BlockTime 按高度计算区块时间戳。
func BlockTime(genesisTimestamp int64, height int) int64 {
    return genesisTimestamp + int64(height) * int64(BlockInterval)
}
```

创世块信息（时间戳、初始参数）硬编码在客户端中。

### 4.2 Block Header（区块头）

```go
type Hash512 = [64]byte

// BlockHeader 区块头结构。
type BlockHeader struct {
    Version   int      // 版本号
    PrevBlock Hash512  // 前一区块哈希
    CheckRoot Hash512  // Hash(交易哈希树根 + UTXO 指纹)，附铸造者签名
    Stakes    int      // 币权销毁量（币天）
    Height    int      // 区块高度
    YearBlock Hash512  // 前一年块哈希（仅当 Height % 87661 == 0 时有效）
}
```

关键字段：

- **CheckRoot**：`Hash(MerkleRoot(TxIDs) + UTXO_Fingerprint)`。区块头中的“签名”是铸造者对该 CheckRoot 的签名，存放在 Coinbase 交易中作为铸造凭证。
- **Stakes**：区块内所有交易的币天销毁量总和。币天 = 未花费输出金额 × 持有天数；花费后清零。
- **YearBlock**：当 `Height % 87661 == 0` 时，该字段引用上一年块哈希，可在不保存完整区块头的情况下进行长程链验证。

### 4.3 Minting Sequence（铸造序列）

当区块时间戳临近：

1. **+30 秒**：排名第 1 的候选者发布区块。时间戳后延 30 秒以最大化交易收集。
2. **每名 +15 秒**：后续候选者按 15 秒间隔发布（排名 2 在 +45s，排名 3 在 +60s，以此类推）。
3. **提前终止**：若候选者在轮到自己前收到并验证了更高排名的区块，则不发布。

池内 20 名成员 **都可能** 发布，但实际仅 1–2 个区块会传播，因为发布时间错开。

### 4.4 Block Acceptance（区块接受）

节点接受区块需满足：

1. 区块结构有效（PrevBlock 正确、CheckRoot 合法等）。
2. 铸造者属于当前高度的最终 Best Pool 成员。
3. 未被区块竞争规则（§4.5）覆盖而拒绝。

#### Fast Relay Strategy（快速转播策略）

可延迟完整区块校验：

1. 若 Coinbase 有效且局部 Merkle 证明确认了区块头，则立即转播。
2. 同步完整交易 ID 列表；请求并验证缺失交易。
3. 重算完整 Merkle 树以确认区块头，完成校验。

候选者在未完成对更优区块的完整验证前 **不得** 停止发布。

### 4.5 Block Competition（区块竞争）

同一高度出现多个有效区块时：

| Scenario | Rule |
|----------|------|
| Same minter, multiple blocks | 交易总手续费 **更低** 的区块获胜（抑制多签竞赛）。 |
| Different minters (redundant publish) | 只有当挑战区块的币天销毁量达到领先区块的 **3 倍或以上** 时才获胜（约束交易量操控）。 |

## 5. Fork Resolution（分叉解决）

### 5.1 Fork Detection（分叉检测）

在节点通信中，节点会交换当前区块 ID。若同一高度出现不同 ID，即检测到分叉。

### 5.2 Competition Window（竞争窗口）

- 分叉必须延伸至 **25 个区块**（约 150 分钟）后评估。
- 逐高度比较：取 Coinbase 中的铸凭哈希对比。获胜多数（25 中 13+）的分叉成为主链。
- 若分叉在被发现时已超过 25 个区块（隐蔽分叉），则视为独立合法的侧链并被主链忽略。

```go
const ForkWindowSize = 25

// ResolveFork 分叉评比：逐区块比较铸凭哈希。
// 返回 true 表示 challenger 胜出。
func ResolveFork(main, challenger [ForkWindowSize]Hash512) bool {
    wins := 0
    for i := 0; i < ForkWindowSize; i++ {
        if bytes.Compare(challenger[i], main[i]) < 0 {
            wins++
        }
    }
    return wins > ForkWindowSize/2 // 过半胜出
}
```

### 5.3 Fork Handling Strategy（分叉处理策略）

1. 缓存所有已知分叉。
2. 随新块到达持续评估铸凭哈希，切换到胜出更多的分叉。
3. 当某分叉达到多数（13/25），宣布其为主链。
4. 被放弃分叉中独有的交易被回收进 mempool 重新打包。

### 5.4 Confirmation Safety（确认安全性）

由于分叉竞争仅限最近 25 个区块：

- **确认 25+ 区块的交易即最终确认** — 无分叉可回滚。
- 新币（Coinbase 输出）需 25 个区块确认后方可花费。该规则在花费时校验而非在出块层实现，因此不需要额外分叉协调逻辑。若分叉被放弃，其 Coinbase 输出自然失效，其他交易被回收。

### 5.5 Manual Chain Switching（手动链切换）

若网络分区持续超过 2.5 小时，则 25 区块竞争窗口关闭，两条链各自成为合法链。此时客户端允许用户通过连接目标分叉的节点并同步分叉后的区块头链来手动选择链。

## 6. Bootstrap Procedure（引导启动）

### 6.1 Early-Stage Rules（初段规则）

最初阶段缺少完整的 `-9` 评参历史，需采用特殊规则：

#### Reference Block Selection（评参区块选择）

```go
// RefBlockHeight 获取评参区块高度。
func RefBlockHeight(currentHeight int) int {
    if currentHeight < 9 {
        return 0 // 使用创世块作为评参区块
    }
    return currentHeight - 9
}
```

#### Minting Transaction Eligibility（铸凭交易合法性）

```go
// IsMintTxEligible 判断铸凭交易是否在合法区块范围内。
func IsMintTxEligible(currentHeight, txHeight int) bool {
    if currentHeight < 25 {
        return true // 初段：所有合法交易均可参与
    }
    depth := currentHeight - txHeight
    return depth > 24 && depth <= 80000
}
```

### 6.2 Hundred-Day Expansion Plan（百日扩张方案）

一个分阶段的引导计划，用于分发初始币并建立铸造交易基础：

| Phase | Block Range | Duration | Purpose |
|-------|-------------|----------|---------|
| **Genesis** | Block 0 | — | 链创建。 |
| **Key Expansion** | Blocks 1–10 | ~1 hour | 创建多个接收地址用于后续交易与铸造竞争。 |
| **Accumulation** | Blocks 11–7200 | ~30 days | 观察链运行；如有问题保留中止权。 |
| **Lottery Expansion** | Blocks 7201–24000 | ~70 days | 社区驱动的地址收集与奖励发放，以扩充铸造交易池。 |
| **Open Market** | Block 24001+ | Ongoing | 公共服务启动；外部奖励生效；进入正常自由市场运作。 |

引导期约束：

- Coinbase 交易仅包含单一输出（不含公共服务奖励）。
- 每笔交易的输出数量不得超过其输入数量的 **2 倍**，以控制扩张速度。

## 7. Endpoint Conventions（端点约定）

### 7.1 Convention Types（约定类型）

| Type | Chinese | Enforcement | Description |
|------|---------|-------------|-------------|
| **Protocol** | 协议 | 严格；违反即无效 | 具备最终校验机制的规则。不遵守将破坏系统。 |
| **Convention** | 共约 | 自愿；不可验证 | 基于善意的软性指南，轻微不遵守不致命。 |

### 7.2 Minimum Transaction Fee（最低交易费）— Convention

每 6,000 个区块（约 25 天）计算一次：

```go
const FeeRecalcPeriod = 6000

// MinTransactionFee 计算最低交易费（共约）。
func MinTransactionFee(avgFeeLastPeriod int64) int64 {
    return avgFeeLastPeriod / 4
}
```

这是一条 **共约**——铸造者最终决定是否纳入低手续费交易。然而，节点 **不得** 阻止低费交易的转播，因为铸造者可能已将其打包，其他节点需要验证区块。

### 7.3 Transaction Expiry（交易过期）— Protocol

未确认交易在 **240 个区块**（24 小时）后过期，以交易自身时间戳为准。这是 **协议** 规则——铸造者不得纳入过期交易。

目的：
1. 限定未确认交易池的规模。
2. 为依赖最终性的应用提供时间确定性。

### 7.4 Zero-Confirmation Warning（零确认警告）

系统不强制零确认安全性。若在 mempool 中检测到双花，将向用户显示警告。对大额交易，用户应等待足够区块确认。

### 7.5 Network Announcement（全网通告）

保留一个最小化的中心化机制，用于全网文本公告。消息由授权密钥签名（内置于官方客户端或由社区渠道发布）。明确禁止功能扩展（如可点击升级链接）。

### 7.6 Coin-Day Destruction（币权销毁）

币天度量未花费输出的“持有时长权益”：

```go
// CoinDays 计算币权（币天）。
// amount:    未花费输出的金额
// holdDays:  持有天数
func CoinDays(amount int64, holdDays int) int64 {
    return amount * int64(holdDays)
}
// 花费后币权归零。
```

币天销毁在区块头 `Stakes` 字段中汇总，并作为区块竞争的次级因素（见 §4.5）。

## 8. Design Parameters Summary（设计参数汇总）

| Parameter | Value | Note |
|-----------|-------|------|
| Block interval | 6 分钟 | 固定；时间戳计算得出，不存储 |
| Blocks per year | 87,661 | ≈365.25 天 × 24h × 60min / 6min |
| Minting tx eligible range | `[Height-80000, Height-25]` | 约 11 个月回溯 |
| Reference block offset | Height - 9 | 用于铸凭哈希计算 |
| UTXO fingerprint source | Height - 24 | 深度参与评参区块以防塑造 |
| Best Pool capacity | 20 名候选者 | 按铸凭哈希升序 |
| Sync-authorized members | 后 15 名（排名 6–20） | 利益无关原则 |
| First block publish delay | 时间戳后 +30 秒 | 最大化交易收集 |
| Redundant publish interval | 每名 15 秒 | 错开发布以减少网络洪泛 |
| Fork competition window | 25 个区块（约 150 分钟） | 多数（13/25）胜出 |
| New coin confirmation depth | 25 个区块 | 花费时校验，不在出块层 |
| Min fee recalculation period | 6,000 个区块（约 25 天） | 共约，非协议 |
| Transaction expiry | 240 个区块（24 小时） | 协议；严格执行 |
| Hash algorithm (default) | SHA-512（64 字节） | 用于区块哈希、交易 ID、铸凭哈希 |
| Max stack height (script) | 256 | 脚本执行上限 |
| Max transaction size | 8,192 字节 | 单笔交易上限 |
