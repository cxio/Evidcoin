# Evidence Design Proposal（信元设计提案）

## 1. Overview（概述）

本提案定义 Evidcoin 的三种基础信元（信元，“Evidence Units”）：**Coin**、**Credit**、**Proof**。它们共同构成链上全部信用表达的基石。

交易是信用表达与转移的载体，由输入（引用先前未花费输出）与输出（定义信用内容与接收者）构成。每个输出承载一种信元类型，并由锁定脚本约束。

关键设计原则：

- **Coin** (币金)：可分割的数值型价值——系统的货币/代币。
- **Credit** (凭信)：不可分割、可转移的数据——合同、债券、数字凭证。
- **Proof** (存证)：不可分割、不可转移——链上锚定的存在性证明。

若交易仅包含 Coin，则为纯转账；若同时包含 Credit 或 Proof，则为混合交易。由于链上交易需要手续费，Coin 输入在实践中不可避免。


## 2. Evidence Unit Definitions（信元定义）

### 2.1 Coin（币金）

Coin 表示可量化价值，类似货币或代币。

**Properties:**

- 可分割、可合并，并可进行算术运算。
- 原始创建仅通过 Coinbase（铸币）交易发生。
- 数量以最小单位 `chx` 的变长整数表示。
- 未花费的 Coin 存于 **UTXO**（Unspent Transaction Output）集中。

**Output structure (pseudo-Go):**

```go
// CoinOutput 表示一个币金输出。
type CoinOutput struct {
    Receiver   []byte  // 接收者地址（公钥哈希，48 字节）
    Amount     int64   // 币金数量，最小单位 chx
    Memo       []byte  // 附言，可选，最长 255 字节
    LockScript []byte  // 锁定脚本，最长 1024 字节
}
```

如果用户不使用内置的 `SYS_CHKPASS` 标准验证，接收者可为空或任意48字节。


### 2.2 Credit（凭信）

Credit 表示不可分割、可转移的凭证——合同、债券、证书。

**Properties:**

- 不可拆分，但可转移（类似花费 Coin）。
- 转移时可选择允许修改描述。
- 未转移的 Credit 存于 **UTCO**（UnTransferred Credit Output）集中。
- 任何人都可创建 Credit（类似普通交易）。

**Output structure (pseudo-Go):**

```go
// CreditOutput 表示一个凭信输出。
type CreditOutput struct {
    Receiver     []byte  // 接收者地址（48 字节公钥哈希）
    Creator      []byte  // 创建者标识或引用（< 256 字节）
    Config       uint16  // 2 字节配置位域（见下文）
    Title        []byte  // 标题，人类可读（< 256 字节）
    Description  []byte  // 描述（长度由 Config 低 10 位指定，< 1024 字节）
    AttachmentID []byte  // 附件 ID，可选（< 256 字节，含结构）
    LockScript   []byte  // 锁定脚本
}
```

**Config bit layout (2 bytes):**

| 位 | 名称 | 描述 |
|--------|------|-------------|
| 15 | `NEW` | 新建标记。Credit 初次创建时置位。 |
| 14 | `MUTABLE` | 描述在转移时是否允许修改。 |
| 13 | `MODIFIED` | 本次转移发生描述修改时置位。 |
| 12 | (reserved) | — |
| 11 | `HAS_XFER_COUNT` | 后接 2 字节转移次数上限。 |
| 10 | `HAS_EXPIRY` | 后接变长整数的有效期截止高度。 |
| 0–9 | `DESC_LEN` | 描述内容长度（< 1024 字节）。 |

转移次数和有效期可同时存在，以先到为准。转移次数需在每次转移时递减，截止高度不可变。

在有效高度内，如果当前转移次数已降至0（输入为1，输出为0），则该笔输出不再进入 UTCO 集。

对于高度截止的检查，需要创建一个 `高度=>[Index]` 的索引集，引用有高度截止的凭信条目。当抵达某个高度时，根据索引在 UTCO 集里检索目标，标记或清理移除。

### 2.3 Proof（存证）

Proof 表示静态存在声明——版权声明、证书、子链锚定、主题索引或应用入口点。

**Properties:**

- 不可拆分或转移。
- 不能作为交易输入。
- 任何人都可创建 Proof。

**Output structure (pseudo-Go):**

```go
// ProofOutput 表示一个存证输出。
type ProofOutput struct {
    Creator      []byte  // 创建者标识（< 256 字节），可为空
    Title        []byte  // 标题（< 256 字节），人类可读
    Content      []byte  // 内容，通常为文本（长度由 ContentLen 指定，最大 4095 字节）
    ContentLen   uint16  // 2 字节，低 12 位为内容字节长度
    AttachmentID []byte  // 附件 ID，可选
    IdentScript  []byte  // 识别脚本，供程序化识别和处理
}
```

**ContentLen bit layout (2 bytes):**

| 位 | 名称 | 描述 |
|--------|------|-------------|
| 12–15 | (reserved) | — |
| 0–11 | `CONTENT_LEN` | 内容字节长度（最大 4095）。 |

由于 Proof 不可转移，IdentScript 与锁定脚本用途不同——第三方客户端可以通过类似 GOTO 的逻辑对 Proof 进行程序化识别与处理。


## 3. Output Configuration Byte（输出项配置字节）

每个交易输出都携带 1 字节配置头。

```go
// OutputConfig 输出项配置（1 字节）。
// 高 4 位为标记位，低 4 位为类型值。
type OutputConfig byte

const (
    OutCustomClass  OutputConfig = 1 << 7 // 自定义类：余下 7 位为类 ID 长度
    OutHasAttach    OutputConfig = 1 << 6 // 包含附件
    OutDestroy      OutputConfig = 1 << 5 // 销毁标记
    // bit 4: reserved

    OutTypeCoin     OutputConfig = 1  // 币金
    OutTypeCredit   OutputConfig = 2  // 凭信
    OutTypeProof    OutputConfig = 3  // 存证
    OutTypeMediator OutputConfig = 4  // 介管脚本
)
```

| 位 | 标记 | 描述 |
|-----|------|-------------|
| 7 | `CustomClass` | 置位时，其余 7 位编码私有类 ID 长度（最大 127 字节）。 |
| 6 | `HasAttachment` | 声明包含附件；当 `CustomClass` 置位时改作他用。 |
| 5 | `Destroy` | 销毁 Coin 或终止 Credit 的可转移性。输出不再进入 UTXO 或 UTCO。 |
| 4 | (reserved) | — |
| 3–0 | `Type` | `0` 预留，`1` Coin，`2` Credit，`3` Proof，`4` Mediator。 |

**Destroy semantics:** 置位时，接收者可为 `null`。锁定脚本可为空或只包含一个 `NIL`，也允许使用有意义的脚本。

**Mediator (介管):** 一种特殊输出类型，不能作为交易输入，仅能被其他交易通过脚本跳转指令（如 `GOTO`）引用，用于中介/监管逻辑（如审计脚本）。

**Custom Class (自定义类):** 启用私有应用专用脚本与扩展指令。自定义输出不能作为输入项。最多 127 字节的私有标识用于锚定专用客户端。


## 4. Attachment System（附件系统）

附件系统通过 Depots（数据驿站）P2P 网络将大数据离链存储，仅在交易输出中嵌入附件 ID。

### 4.1 Attachment ID Structure（附件 ID 结构）

```go
// AttachmentID 附件 ID 结构（< 256 字节总长）。
type AttachmentID struct {
    TotalLen       uint8    // ID 总长（1 字节）
    MajorType      uint8    // 附件大类（1 字节，参考 MIME）
    MinorType      uint8    // 附件小类（1 字节）
    FingerprintLen uint8    // 指纹强度：按 4 字节增量（0=>16, 1=>20, ..., 12=>64）
    Fingerprint    []byte   // 附件指纹，BLAKE3 哈希（最低 128 bit / 16 字节）
    ShardCount     uint16   // 分片数量（< 65536）
    ShardTreeRoot  [48]byte // 片组哈希树根（二元结合，叶子含 2 字节序号前缀）
    Size           int64    // 附件大小（变长整数，单位：字节）
}
```

**要点：**

- **Fingerprint:** 附件指纹是对数据本身的完整哈希，不分片。
- **Hash algorithm:** 附件指纹使用 BLAKE3——因其速度与流式能力而选用，区别于交易/区块哈希的 SHA-512。
- **Fingerprint length** 由用户选择（最小 128 位），编码为 4 字节增量索引。
- **ShardTreeRoot:** 片组哈希用于分片验算，与附件指纹的逻辑不同。双哈希可强化附件安全性（采用不同的哈希算法）。
- **Shard tree:** 二元哈希树（类 Merkle）。每个叶子为分片数据的 48 字节哈希，前缀 2 字节序号（每叶共 50 字节）。采用 SHA3-384 算法计算。
- 若单片最大 2 MB、最多 65,535 片时，附件可表示约 128 GB 数据。

### 4.2 Shard Verification（分片验证）

在不下载完整附件的情况下验证单个分片：

1. 向源节点请求特定序位的分片数据及其 Merkle 证明路径。
2. 计算接收分片数据的哈希（48字节）。
3. 在哈希前加上 2 字节序号前缀（由验证者控制，非源节点提供）。
4. 与证明路径哈希结合，重算分片树根。
5. 与附件 ID 中的 `ShardTreeRoot` 对比。

> **注：**
> 这样的设计可约束源节点提供准确序位的分片，而不是任意分片（防止作弊）。

### 4.3 Shard Count Rules（分片数量规则）

| `ShardCount` | 含义 |
|---|---|
| `0` | 无分片。`ShardTreeRoot` 字段位取消（紧跟附件大小值）。 |
| `1` | 逻辑上未分片。`ShardTreeRoot` 等于完整附件的哈希（非 BLAKE3 算法）。 |
| `> 1` | 分片。`ShardTreeRoot` 由有序分片哈希树计算。 |

### 4.4 Attachment Size（附件大小）

附件大小仅声明而不由区块链节点强制验证——链上无法校验离链数据尺寸。虚报大小可能降低 Depot 节点的存储意愿（被视为不当行为或数据损坏）。


## 5. Signature Scheme（签名方案）

输出项所有权通过数字签名证明，这是标准的内建校验方式。

### 5.1 Single Signature（单签名）

常见情形：单一私钥签名交易以授权花费。

```go
// SingleSigUnlock 单签名解锁数据。
type SingleSigUnlock struct {
    Signature []byte  // 签名
    PublicKey []byte  // 对应的公钥
}
```

### 5.2 Multi-Signature（多重签名）

支持 `M-of-N` 方案，以提升社会化安全与灵活性。

- **N**：参与公钥总数。
- **M**：所需最小签名数（M ≤ N）。
- `m/N` 比例编码为 2 字节（`1+1`），最高支持 `255/255`。

**Multi-sig address construction:**

```go
// 多重签名地址构造流程
// 1. 对 N 个公钥分别计算 SHA3-384 哈希
//    PKH_i = SHA384(pubKey_i)
// 2. 公钥哈希有序串连，前置 m/N 配比
//    PKHs = SHA384( [m, N] || PKH_1 || PKH_2 || ... || PKH_N )
// 3. PKHs 编码为文本形式即为多签地址
```

隐私特性：多签地址在外观上与单签地址不可区分。参与者仅需共享公钥哈希（而非原始公钥），提升安全性并支持匿名参与。

**Multi-sig unlock data:**

```go
// MultiSigUnlock 多重签名解锁数据。
type MultiSigUnlock struct {
    Signatures [][]byte  // m 个签名
    PublicKeys [][]byte  // m 个对应公钥
    Complement [][]byte  // N-m 个未参与签名的公钥哈希
}
// m/N 配比可由 len(PublicKeys) 和 len(Complement) 推算。
```

**Multi-sig verification procedure:**

1. 从解锁数据规模推导 `m` 与 `N`。
2. 对每个提供的公钥计算哈希：`PKH_i = SHA384(pubKey_i)`。
3. 与补全哈希合并、排序、串联，前置 `[m, N]`，计算复合哈希。
4. 与输出中接收者公钥哈希对比。
5. 验证 `m` 个签名。


## 6. Authorization Flags（授权标志）

1 字节标志配置签名覆盖的交易部分，从而支持灵活的授权模式。

```go
// SigFlag 签名授权标志（1 字节）。
type SigFlag byte

const (
    // 独项（self-contained）
    SIGIN_ALL    SigFlag = 1 << 7  // 全部输入项
    SIGIN_SELF   SigFlag = 1 << 6  // 仅当前输入项

    // 主项（primary, requires auxiliary）
    SIGOUT_ALL   SigFlag = 1 << 5  // 全部输出项
    SIGOUT_SELF  SigFlag = 1 << 4  // 与当前输入同序位的输出项

    // 辅项（auxiliary, requires primary）
    SIGRECEIVER  SigFlag = 1 << 0  // 输出的接收者
    SIGCONTENT   SigFlag = 1 << 1  // 输出内容（Coin: amount/memo; Credit: creator/config/title/desc/attachID）
    SIGSCRIPT    SigFlag = 1 << 2  // 输出的锁定脚本
    SIGOUTPUT    SigFlag = 1 << 3  // 完整输出条目（receiver + content + script）
)
```

**组合规则：**

| 类别 | 规则 | 示例 |
|----------|------|---------|
| 独项 | 可单独使用或与其他组合。 | `SIGIN_ALL` |
| 主项 | 必须与辅项组合。 | `SIGOUT_ALL \| SIGRECEIVER` |
| 辅项 | 必须与主项组合。 | `SIGOUT_SELF \| SIGOUTPUT` |

**常见的配置：** `SIGIN_ALL | SIGOUT_ALL | SIGOUTPUT` — 覆盖所有输入与全部输出的完整数据。

**灵活授权示例：**

- `SIGIN_ALL | SIGOUT_SELF | SIGOUTPUT` — 所有输入 + 仅同序位输出。
- `SIGIN_SELF | SIGOUT_ALL | SIGRECEIVER` — 仅签名者自己的输入 + 全部输出接收者。


## 7. Signature Separation（签名分离机制）

签名 **excluded** 于 `TxID` 计算之外。这是有意为之的设计选择，具有重要影响。

### 7.1 TxID Computation（TxID 计算）

```go
// TxHeader 交易头结构。
type TxHeader struct {
    Version   int      // 版本号
    Timestamp int64    // 交易时间戳（Unix 纳秒）
    HashBody  [64]byte // 数据体哈希（SHA-512）
}

// TxID = SHA512(TxHeader)
// HashBody = SHA512(InputHash || OutputHash)
//
// 签名数据不参与 HashBody 计算，因此不影响 TxID。
```

### 7.2 Rationale（设计理由）

1. **Malleability resistance:** 签名不参与 TxID，第三方无法通过修改签名改变 TxID（消除早期比特币的交易可塑性问题）。
2. **Signature discardability:** 签名在区块纳入时验证。一旦区块确认，并由双链耦合（区块 ID 链 + UTXO/UTCO 指纹链）固定位置，签名可安全丢弃以回收存储。
3. **Long-term security:** 签名被丢弃后，链的完整性依赖双链耦合机制而非持久签名。即便未来签名算法被攻破，链历史仍不可篡改，具备后量子韧性。

### 7.3 Dual-Chain Coupling（双链耦合）

长期链完整性由两条互锁的哈希链维持：

- **Block-ID Chain (区块 ID 链):** 每个区块头包含前一区块哈希，形成顺序链。
- **UTXO/UTCO Fingerprint Chain (UTXO/UTCO 指纹链):** 每个区块提交累积 UTXO 和 UTCO 状态，形成并行完整性链。

两条链共同提供密码学证明，确保区块及其交易内容未被篡改，且不依赖签名数据。


## 8. Public-Key Hash and Address Format（公钥哈希与地址格式）

### 8.1 Public-Key Hash（公钥哈希）

- **Algorithm:** SHA3-384（48 字节）。
- **Rationale:** 相较 SHA-512 更短，因为 UTXO/UTCO 条目是短暂的——仅在花费前存在。384 位安全强度足以覆盖 UTXO/UTCO 生命周期，同时节省频繁访问的 UTXO/UTCO 集存储。

```go
const PubKeyHashLen = 48 // SHA3-384 输出长度（字节）

// PubKeyHash 计算公钥哈希。
// pkh = SHA384(publicKey)
type PubKeyHash [48]byte
```

### 8.2 Address Encoding（地址编码）

地址是公钥哈希的人类可读文本表示。

**Encoding procedure:**

1. 在公钥哈希前添加网络识别前缀：`prefix || PKH`。
2. 对结果哈希，取最后 4 字节作为 **checksum**。
3. 将校验码拼接到原始公钥哈希（不含前缀）：`PKH || checksum`。
4. 将字节序列编码为文本（可能沿用 Base58）。
5. 再次添加识别前缀，得到最终地址：`prefix + encodedText`。

**Verification procedure:**

1. 去除前缀，将文本部分解码为字节。
2. 拆分为公钥哈希（前 48 字节）与校验码（后 4 字节）。
3. 重新计算：哈希 `prefix || PKH`，取最后 4 字节。
4. 对比，一致即为有效地址。

```go
// Address 地址结构示意。
type Address struct {
    Prefix  string       // 网络识别前缀
    PKHash  PubKeyHash   // 48 字节公钥哈希
    Check   [4]byte      // 校验码
}

// Encode 将地址编码为可读文本。
// result = Prefix + Base58(PKHash || Check)
func (a *Address) Encode() string { /* ... */ }

// Verify 校验地址的完整性。
func (a *Address) Verify() bool { /* ... */ }
```

**Privacy:** 单签与多签地址在外观上完全一致，避免观察者区分账户类型。


## 9. Evidence Lifecycle Management（信元生命周期管理）

### 9.1 Coin Lifecycle（币金生命周期）

```graph
 [Coinbase Minting] ──► [UTXO Set] ──► [Spent as Input] ──► [New Outputs]
                            │
                            └──► [Destroy Flag] ──► [Lost from UTXO]
```

1. **Creation:** Coin 仅由 Coinbase 交易创建。
2. **Existence:** 未花费的 Coin 存于 UTXO 集。
3. **Spending:** 有效解锁脚本从 UTXO 集消耗 Coin 并创建新输出。
4. **Destruction:** 输出项设置 `Destroy` 标记会让该输出项不再进入 Coin 流通。
5. **UTXO cleanup:** 源交易的所有输出被花费后，关联的 Coin 会从 UTXO 集彻底移除。

### 9.2 Credit Lifecycle（凭信生命周期）

```graph
 [Creation (NEW flag)] ──► [UTCO Set] ──► [Transfer] ──► [UTCO Set (new owner)]
      │                         │               │
      │                         │               └──► [Revision if MUTABLE]
      │                         │
      │                         ├──► [Destroy Flag] ──► [Lost from UTCO]
      │                         │
      │                         └──► [Expiry / Transfer-count exhausted]
      │                                  │          |
      │                                  │          └──► [Lost from UTCO]
      │                                  └──► [Removed from UTCO]
      │
      └──► [Mutability: can transition MUTABLE → IMMUTABLE (one-way)]
```

1. **Creation:** 任何人都可创建 Credit。`NEW` 标记（第 15 位）置位，创建者决定可变性。
2. **Transfer:** 类似花费 Coin。Credit 从 UTCO 集消耗并以新持有人重建。
    - 若 `MUTABLE`：描述可修改，若已修改必须设置 `MODIFIED` 标记。
    - 若不可变：仅接收者与锁定脚本可变更；创建者字段转为引用。
3. **Mutability transition:** Credit 可从可变转为不可变（单向且不可逆）。
4. **Transfer-count exhausted:** 在转移校验时被动检查：当输入的转移计数为1，输出为0时，新的输出项不再进入 UTCO 集，即不再可转移。
4. **Expiry:** 通过一个额外的 `高度=>[Index]` 的引用索引集，当抵达某个高度时，对 UTCO 集进行清理。
5. **UTCO cleanup:** 源交易的所有凭信输出到期后，关联的过期 Credit 会从 UTCO 集彻底移除。
6. **Destruction:** 设置 `Destroy` 标记终止可转移性。

> **注：**
> 转移计次在每次转移时递减，高度截止清理通过引用索引集完成。

**Compliance checks on transfer:**

| 条件 | 允许变更 |
|---|---|
| 不可变 | 仅接收者与锁定脚本可变；创建者字段转为引用。 |
| 可变 + 已修改 | 描述可变更，必须置 `MODIFIED` 标记。 |
| 可变 → 不可变 | 单向锁定可变性。 |

### 9.3 Proof Lifecycle（存证生命周期）

```graph
 [Creation] ──► [On-chain (permanent)]
                    │
                    └──► [Referenced via IdentScript]
```

1. **Creation:** 任何人都可创建 Proof，并永久写入链上。
2. **Immutability:** Proof 一经创建即不可修改或转移。
3. **No UTCO presence:** Proof 不进入 UTCO 集（不可转移）。
4. **Referencing:** 第三方应用可借助于 IdentScript 实现自动化识别和可能的各种业务逻辑。

### 9.4 Lifecycle Summary（生命周期总结）

| 属性 | Coin | Credit | Proof |
|---|---|---|---|
| 可分割 | 是 | 否 | 否 |
| 可转移 | 是（花费） | 是（转移） | 否 |
| 在UTXO集 | 是 | - | - |
| 在UTCO集 | - | 是（直到销毁/过期/次数归零） | - |
| 链上永久性 | 是 | 是 | 是 |
| 可销毁 | 是（Destroy） | 是（Destroy/过期/次数归零） | 不适用 |
| 创建者 | 仅 Coinbase | 任何人 | 任何人 |
| 含锁定脚本 | 是 | 是 | 否（有 IdentScript） |
| 支持附件 | 否 | 是 | 是 |


## 10. Design Considerations（设计考量）

### 10.1 UTXO Efficiency（UTXO 效率）

- 公钥哈希使用 SHA3-384（48 字节），减少 UTXO 条目尺寸。
- Credit 次数归零采用被动检查——仅在转移时判断，无需扫描。
- Credit 高度截止通过索引集指向局部清理，避免全量扫描 UTCO 集。
- Proof 从不进入 UTCO 或 UTXO 集，保持其紧凑。

### 10.2 Privacy（隐私）

- 单签与多签地址外观不可区分。
- 多签参与者仅共享公钥哈希而非原始公钥。
- 自定义类输出为公共网络上的私有应用提供通道。

### 10.3 Extensibility（可扩展性）

- 输出配置字节预留位用于未来扩展。
- 自定义类输出支持最多 127 字节的私有类标识。
- Mediator 输出支持跨交易脚本组合，用于复杂流程（审计、合规）。
- 附件分片与 Depot P2P 网络将大数据存储与区块链本体解耦。

### 10.4 Security（安全性）

- 签名分离消除交易可塑性。
- 双链耦合（区块 ID 链 + UTXO/UTCO 指纹链）提供独立于签名的长期完整性。
- 附件指纹使用 BLAKE3 提供高速验证，支持可变长度以提供自由度。
- 附件分片的哈希树使用 SHA3-384，与附件整体数据的 BLAKE3 不同，增强安全性。
- 公钥哈希使用 SHA3-384 提供 192 位安全强度，足以覆盖短暂的 UTXO/UTCO 生命周期。
