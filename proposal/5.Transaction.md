# Transaction Design Proposal（交易设计提案）

> 本提案定义 Evidcoin 区块链的交易模型，涵盖结构、哈希、UTXO 指纹、Coinbase 交易、存储与大小/费用约束。


## 1. Overview（概述）

交易是 Evidcoin 信用转移的基本载体。不同于比特币仅将交易历史作为存储，Evidcoin 的交易历史必须支持下游需求：脚本应用识别、中介脚本引用与第三方开发。

设计重点：

- **Verifiability**：使用哈希树对输入与输出进行独立验证。
- **Retrievability**：按年度与 TxID 的结构化索引，便于高效检索。
- **Signature separation**：签名不参与 TxID 计算，支持灵活授权模型。
- **Compactness**：MaxTxSize = 8192 字节，输入引用更省空间。


## 2. Transaction Header（交易头）

交易头是完整交易的紧凑抽象，类似区块头对区块的抽象。

```go
// TxHeader 交易头结构。
// 交易头的哈希即为交易 ID（TxID）。
type TxHeader struct {
    Version   int      // 版本号
    Timestamp int64    // 交易时间戳（Unix 纳秒）
    HashBody  Hash512  // 交易体哈希
}
```

### 2.1 TxID Computation（交易 ID 计算）

```
TxID = SHA-512( TxHeader )
```

关键规则：**Signatures are excluded from TxID computation.** TxID 仅由交易头派生，而交易头包含的 `HashBody` 仅由输入与输出计算而来。该分离防止交易可塑性，并允许签名独立验证。

### 2.2 HashBody Computation（交易体哈希计算）

```
HashBody = SHA-512( InputHash || OutputHash )
```

其中 `InputHash` 与 `OutputHash` 分别为输入集合与输出集合的哈希树根，`||` 表示字节拼接。


## 3. Transaction Body（交易体）

交易体由两部分组成：**inputs**（信用来源）与 **outputs**（信用去向）。

### 3.1 Inputs（输入项）

每个输入引用已确认交易中的未花费输出（UTXO）。

> **Rule**：未确认交易的输出不能作为输入。这保证了组队校验下的交易独立性。

#### 3.1.1 Input Structure（输入项结构）

一个输入由 3–4 个字段组成：

| 字段 | 大小 | 描述 |
|-------|------|-------------|
| Year | varint | 被引用交易的年度（粗粒度时间约束） |
| TxIDRef | 64 字节（首领）/ 20 字节（其余） | 交易 ID 引用 |
| OutIndex | varint | 被引用交易中的输出序位 |
| TransferIndex | varint（可选） | 用于凭信转移：当前交易中的目标输出位置 |

```go
// LeadInput 首领输入，使用完整的交易 ID 引用。
type LeadInput struct {
    Year          int       // 交易所在年度
    TxID          Hash512   // 完整交易 ID（64 字节）
    OutIndex      int       // 输出序位
    TransferIndex int       // 凭信转出序位（可选）
}

// RestInput 非首领输入，使用截断的交易 ID 引用以节省空间。
type RestInput struct {
    Year          int       // 交易所在年度
    TxIDPart      [20]byte  // 交易 ID 前 20 字节
    OutIndex      int       // 输出序位
    TransferIndex int       // 凭信转出序位（可选）
}
```

**Design rationale**：

- **lead input** 使用完整 64 字节 TxID，便于凭信所有者检索与稳健验证。
- **remaining inputs** 使用 20 字节截断引用以节省空间。由于所有输入都会针对当前 UTXO 集解析（由 UTXO 指纹校验），20 字节前缀已足够，实际碰撞可忽略。

#### 3.1.2 Lead Input Constraints（首领输入约束）

为抗洪泛保护（参见 “Team-based Verification” 设计）：

- 首领输入必须为 **coin** 类型，且在所有 coin 输入中具有 **largest coin-age**。
- 若交易最终未通过完整校验，首领输入将进入 **blacklist**，冻结 24 小时。

#### 3.1.3 Input Hash Tree（输入哈希树）

The input set is hashed into a two-layer tree with the lead input separated:

```
InputHash = SHA-512( LeadHash || RestHash )

LeadHash  = SHA-512( Year || TxID[64] || OutIndex )

RestHash  = SHA-512( RestInput_1 || RestInput_2 || ... || RestInput_N )
```

分离首领输入使铸造者在不处理全部输入的情况下即可快速定位并验证凭信所有权。

#### 3.1.4 Input Validation（输入验证）

Each input is validated via script execution:

```
UnlockScript + LockScript → Execute → Success = Valid
```

解锁脚本提供所有权证明；锁定脚本（来自被引用输出）定义花费条件。


### 3.2 Outputs（输出项）

每个输出定义信用去向——接收者获得币金、凭信或存证。

#### 3.2.1 Output Structure（输出项结构）

```go
// Output 交易输出项。
type Output struct {
    Serial     int        // 输出序位（从 0 开始）
    Config     byte       // 配置字节（类型 + 标记位）
    Amount     int64      // 币金数量（按最小单位 chx）
    Address    [48]byte   // 接收地址（SHA3-384 公钥哈希）
    LockScript []byte     // 锁定脚本（最大 1024 字节）
    // 以下字段按信元类型选择性存在
    Memo       []byte     // 附言（币金，最大 255 字节）
    Creator    []byte     // 创建者（凭信/存证）
    Title      []byte     // 标题（凭信/存证，最大 255 字节）
    Desc       []byte     // 描述（凭信/存证）
    AttachID   []byte     // 附件 ID（可选）
    CredConfig uint16     // 凭信配置（2 字节）
}
```

#### 3.2.2 Output Config Byte（输出配置字节）

The 1-byte config encodes type and flags:

```graph
Bit 7: Custom class    — When set, remaining 7 bits encode class ID length.
Bit 6: Has attachment  — Declares attachment presence (repurposed if Bit 7 set).
Bit 5: Burn flag       — Marks coin destruction or credential termination.
Bit 4: (Reserved)
Bits [3:0]: Type value:
    0 = Reserved
    1 = Coin         — Value transfer, can be UTXO input source.
    2 = Credential   — Credit certificate, transferable, can be UTXO input source.
    3 = Attestation  — Existence proof, NOT transferable, cannot be input source.
    4 = Intermediary — Receives cross-transaction script jumps (GOTO/EMBED).
```

#### 3.2.3 Address Format（地址格式）

地址由公钥哈希派生：

- **Hash algorithm**：SHA3-384，生成 48 字节公钥哈希。
- **Single-signature**：`Address = SHA3-384( pubKey )`
- **Multi-signature**：`Address = SHA3-384( <m/N> || sort(PKH_1 || PKH_2 || ... || PKH_N) )`
    - `m/N` 前缀为 2 字节（各 1 字节），支持最高 255-of-255。
    - 多签与单签地址外观不可区分（隐私）。

`null` 地址表示销毁目的地——发送到 `null` 的输出不进入 UTXO 集。

**Address encoding**（人类可读形式）：

1. 在公钥哈希前添加识别前缀。
2. 对带前缀数据哈希，取最后 4 字节作为 **checksum**。
3. 将校验码拼接到公钥哈希（不含前缀），编码为文本（改造 Base32）。
4. 再加识别前缀得到最终地址字符串。

#### 3.2.4 Output Hash Tree（输出哈希树）

输出形成二元类 Merkle 哈希树：

```
OutputHash = SHA-512( BinaryTree( Output_0, Output_1, ..., Output_N ) )
```

每个输出作为叶子节点单独哈希。二元树结构可在不处理全集的情况下，对任一输出进行独立验证与位置检索。

#### 3.2.5 Special Output Types（特殊输出类型）

**Burn outputs**：当燃烧标记（Bit 5）置位时，输出从 UTXO 集移除。地址可为 `null`，锁定脚本可为空或仅含简单 `NIL`。

**Intermediary scripts**：类型 4 输出作为跨交易跳转目标。它们不能作为 UTXO 输入源——仅能通过脚本指令（`GOTO`、`EMBED`）引用。连续跨交易跳转会被限频以保证安全。

**Custom classes**：Bit 7 置位的类型。包含专用客户端的私有扩展指令。类 ID 最多 127 字节用于客户端识别。不能作为 UTXO 输入源。


## 4. Signature Model（签名模型）

签名证明输入所有权，但与决定 TxID 的交易体 **structurally separated**。

### 4.1 Single Signature（单签名）

标准情形：单一私钥签名交易，足以满足大多数个人转账。

### 4.2 Multi-Signature（多重签名）

M-of-N scheme where M out of N key holders must sign.

**Unlock data for multi-sig verification**：

| 组件 | 描述 |
|-----------|-------------|
| Signature set | 参与私钥的 M 个签名 |
| Public key set | 对应的 M 个公钥 |
| Complement set | 未签名参与者的 N−M 个公钥哈希 |

**Verification process**：

1. 由公钥集与补全集规模计算 `m/N`。
2. 对公钥集中的每个公钥进行哈希。
3. 将公钥哈希与补全哈希合并、排序、前置 `m/N` 并计算复合哈希。
4. 与输出地址哈希对比——匹配即身份有效。
5. 逐一验证签名集中的签名。

### 4.3 Signature Authorization Types（签名授权种类）

1 字节配置控制签名覆盖范围：

```
Bit 7: SIGIN_ALL     — All inputs
Bit 6: SIGIN_SELF    — Current input only
Bit 5: SIGOUT_ALL    — All outputs (coin, credential, attestation)
Bit 4: SIGOUT_SELF   — Output at same index as current input
Bit 3: SIGOUTPUT     — Full output entry (receiver + content + script)
Bit 2: SIGSCRIPT     — Output's lock script only
Bit 1: SIGCONTENT    — Output's content only
Bit 0: SIGRECEIVER   — Output's receiver only
```

**Usage rules**：

- **Independent bits**（7、6）：可单独使用。例如 `SIGIN_ALL` 覆盖所有输入。
- **Primary bits**（5、4）：必须与辅项（3–0）组合。例如 `SIGOUT_ALL | SIGRECEIVER`。
- **Auxiliary bits**（3–0）：必须配合主项。

**Most common configuration**：`SIGIN_ALL | SIGOUT_ALL | SIGOUTPUT` ——覆盖所有输入与全部完整输出条目。


## 5. Coinbase Transaction（铸币交易）

Coinbase 交易是每个区块的第一笔交易（索引 `[0]`）。它没有输入——从无到有创建新币。

### 5.1 Coinbase Structure（铸币交易结构）

```go
// CoinbaseTx 铸币交易特殊结构。
type CoinbaseTx struct {
    Header      TxHeader   // 标准交易头
    BlockHeight int        // 区块高度
    MeritProof  []byte     // 择优凭证（铸造者证明）
    TotalReward int64      // 收益总额
    FreeData    []byte     // 自由数据（最大 256 字节）
    Outputs     []Output   // 收益分配输出
}
```

### 5.2 Revenue Composition（收益构成）

```
TotalReward = BlockReward + TransactionFees + LotteryRetention
```

- **BlockReward**：每区块铸造的新币（递减计划）。
- **TransactionFees**：总手续费仅 **50%** 计入 Coinbase 收入——其余 50% 永久销毁，形成通缩压力。
- **LotteryRetention**：来自彩票奖励池的保留部分。

### 5.3 Revenue Distribution（收益分成）

Coinbase 输出将奖励分配给多方：

| 接收方 | 描述 |
|-----------|-------------|
| Minter (check team) | 区块铸造奖励份额 |
| Credential minter | 凭信交易提供者奖励 |
| Blockqs | 区块查询服务节点 |
| Depots | 数据驿站服务节点 |
| STUN services | NAT 穿透服务提供者 |

### 5.4 Minting Process（铸造流程）

1. **Application**：合格铸造者（择优池成员）向管理层提交择优凭证。
2. **Information exchange**：管理层返回手续费总额、团队奖励地址、服务地址与铸币金额。
3. **Construction**：铸造者按分配规则构造 Coinbase 交易并提交。
4. **Verification**：管理层验证 Coinbase、打包区块，并返回哈希树验证路径（含 TreeRoot 与 UTXO 指纹）。
5. **Signing**：铸造者通过哈希路径确认其 Coinbase 被包含后签名 CheckRoot 并提交签名。
6. **Publication**：管理层构造区块头并广播。

### 5.5 Low-Revenue Principle（低收益原则）

若同一铸造者在同一高度签名多个区块，**only the block with the lowest revenue is valid**。该规则防止多签并激励及时出块。


## 6. UTXO Model and Fingerprint（UTXO 模型与指纹）

### 6.1 UTXO Set Definition（UTXO 集定义）

UTXO 集由已确认交易的所有未花费输出组成，由前一区块决定。

**Exclusions from UTXO**：

- 未确认交易输出（不可链式花费）。
- 置位燃烧标记的输出。
- 存证输出（type 3，不可转移）。
- 介管脚本输出（type 4）。
- 自定义类输出（Bit 7 置位）。
- 过期凭信（达到转移次数或时限）。

### 6.2 UTXO Fingerprint — 4-Level Hierarchical Hash（UTXO 指纹 — 4 级层次哈希）

UTXO 指纹是具有 **4 hierarchical levels** 的宽成员哈希校验树，旨在最小化输出变化时的重算成本。

```graph
Level 1 (Root):    UTXOFingerprint = SHA-512( Year_1 || Year_2 || ... || Year_N )
Level 2 (Year):    YearHash_y      = SHA-512( TxHash_1 || TxHash_2 || ... )
Level 3 (Tx):      TxHash_t        = SHA-512( OutHash_1 || OutHash_2 || ... )
Level 4 (Output):  OutHash_o       = SHA-512( UTXO output data )
```

```go
// UTXOFingerprint 4 级层次哈希结构。
//
// Level 1: 年度级 — 按交易时间戳的 UTC 年度分组
// Level 2: 交易级 — 同一年度内按交易 ID 分组
// Level 3: 输出级 — 同一交易内按输出序位分组
// Level 4: 哈希叶 — 单个 UTXO 输出数据的哈希
type UTXOFingerprint struct {
    Root      Hash512                // 指纹根哈希
    YearNodes map[int]*YearNode      // 年度 → 年度节点
}

type YearNode struct {
    Year    int                      // UTC 年度
    Hash    Hash512                  // 年度哈希
    TxNodes map[Hash512]*TxNode      // TxID → 交易节点
}

type TxNode struct {
    TxID    Hash512                  // 交易 ID
    Hash    Hash512                  // 交易级哈希
    Outputs map[int]Hash512          // 输出序位 → 输出哈希
}
```

**Design benefits**：

- **Incremental update**：UTXO 被花费时，仅需重算受影响分支（output → transaction → year → root）。
- **Year-based partitioning**：顶层按交易时间戳年度（UTC）分组，提供自然分片且粒度适中。
- **Dual-path history protection**：配合区块 ID 链，UTXO 指纹提供第二条独立的历史完整性证明。
- **Fast node bootstrap**：新节点可通过最新区块头中的指纹验证当前 UTXO 集，无需重放全历史。

### 6.3 CheckRoot（校验根）

CheckRoot 将交易哈希树与 UTXO 指纹链接为区块头中的单一可验证值：

```
CheckRoot = SHA-512( TxTreeRoot || UTXOFingerprint )
```

Where:
- `TxTreeRoot` is the Merkle-like binary hash tree root of all transaction IDs in the block (leaves are TxIDs with 3-byte sequence prefix).
- `UTXOFingerprint` is the root hash of the 4-level UTXO fingerprint structure.

铸造者对 `CheckRoot` 签名，管理层构造包含 `CheckRoot` 的区块头。这形成 **information separation**：铸造者可通过哈希路径验证其 Coinbase 被包含，但无法看到（或操控）完整区块组成。

### 6.4 UTXO Set Transition（UTXO 集转换）

For block at height `H`:

```graph
UTXO_current(H)   = The UTXO set for block H (before applying block H's transactions)
UTXO_result(H)    = UTXO_current(H) − spent_by(H) + new_outputs(H) + coinbase(H)
UTXO_current(H+1) = UTXO_result(H)
```

区块 `H` 的 UTXO 指纹由 `UTXO_current(H)` 计算——即在应用区块 H 交易之前。这提供充分计算时间，并形成可逆验证的链式约束。

**Reverse verification**：给定 `UTXO_current(H+1)` 与区块 `H` 的交易，可反推 `UTXO_current(H)` 并与区块 H 的指纹比对。该过程可向历史任意点迭代。


## 7. Transaction Storage and Retrieval（交易存储与检索）

完整交易存储由外部第三方公共服务提供，而非区块链核心。

### 7.1 Storage Architecture（存储架构）

| 方面 | 服务 | 索引 | 目的 |
|--------|---------|-------|---------|
| 数据 | Blockqs | Year + TxID | 为用户提供完整交易数据 |
| 校验 | Blockqs | Year + BlockHeight | 区块内 TxID 列表与哈希树验证路径 |
| 附件 | Depots | AttachID | 通过 P2P 文件共享的附件数据 |

### 7.2 Query and Verification Flow（查询与验证流程）

给定 `TxID` 与时间戳（或年度）：

1. **Locate**：通过 year + TxID 查询 Blockqs，获取完整交易数据与元信息。
2. **Position**：元信息包含区块高度与区块内位置索引。
3. **Verify**：从 Blockqs 获取哈希树验证路径，并结合用户本地区块头链进行验证：
    - 由交易数据重算 TxID。
    - 通过验证路径确认 TxID 被包含在区块交易哈希树中。
    - 确认树根与区块头中的 `CheckRoot` 一致。

用户的 **local block header chain** 是所有交易验证的信任锚。

### 7.3 Attachment Storage（附件存储）

附件存储在外部 Depots，通过 P2P 传输。

**Attachment ID structure** (variable length, < 256 bytes total):

```go
// AttachmentID 附件标识结构。
type AttachmentID struct {
    TotalLen      byte       // ID 总长
    MajorType     byte       // 附件大类
    MinorType     byte       // 附件小类
    FingerprintLv byte       // 指纹强度等级（0=16B, 1=20B, ... 12=64B）
    Fingerprint   []byte     // BLAKE3 哈希指纹（16–64 字节）
    ShardCount    uint16     // 分片数量（最大 65535）
    ShardTreeHash [48]byte   // 片组哈希树根（SHA3-384）
    DataSize      int        // 附件大小（变长整数，单位：字节）
}
```

**Shard verification**：在部分数据检索时，每个分片可通过序号前缀哈希与至分片树根的 Merkle 路径独立验证。


## 8. Transaction Size and Fee Constraints（交易大小与费用约束）

### 8.1 Size Limits（大小限制）

| 常量 | 值 | 描述 |
|----------|-------|-------------|
| MaxTxSize | 8192 bytes | 单笔交易最大尺寸 |
| MaxLockScript | 1024 bytes | 锁定脚本最大长度 |
| MaxUnlockScript | 4096 bytes | 解锁脚本最大长度 |
| MaxMemo | 255 bytes | 币金附言最大长度 |
| MaxTitle | 255 bytes | 凭信/存证标题最大长度 |
| MaxCredDesc | 1023 bytes | 凭信描述最大长度（10 位长度） |
| MaxAttestContent | 2047 bytes | 存证内容最大长度（11 位长度） |
| MaxFreeData | 255 bytes | Coinbase 自由数据最大长度 |

### 8.2 Fee Calculation（费用计算）

交易手续费采用隐式计算：

```
Fee = Sum(input coin values) − Sum(output coin values)
```

手续费必须非负。区块内收取的总手续费：

- **50% is burned** ——永久移除流通，形成通缩压力。
- **50% is distributed** ——作为铸造团队与公共服务的收入进入 Coinbase 交易。

### 8.3 Transaction Priority（交易优先级）

区块收录遵循以下优先级规则：

1. **Earlier input timestamps** ——引用更早 UTXO 的交易优先。
2. **Higher coin-age burn or higher fees** ——次级裁决。


## 9. Hash Tree in Block（区块内的哈希校验树）

区块内所有交易组织为类 Merkle 的二元哈希树：

```
TxTreeRoot = BinaryTree( [3B_seq || TxID_0], [3B_seq || TxID_1], ..., [3B_seq || TxID_N] )
```

- 每个叶子是带 3 字节序号前缀的 TxID，用于位置识别。
- 序号前缀支持按位置随机提取并验证任意交易。
- 树根与 UTXO 指纹共同参与 `CheckRoot` 计算。

该设计支持区块发布优化：在区块同步时，初始仅广播 16 字节 TxID 前缀。接收者与本地交易池比对，仅请求缺失交易。


## 10. Summary of Hash Relationships（哈希关系总结）

```graph
                        ┌─────────────────────────┐
                        │      Block Header       │
                        │  ┌───────────────────┐  │
                        │  │     CheckRoot     │  │
                        │  └─────────┬─────────┘  │
                        └────────────┼────────────┘
                                     │
                        ┌────────────┴────────────┐
                        │                         │
                  ┌─────┴──────┐        ┌─────────┴────────┐
                  │ TxTreeRoot │        │ UTXO Fingerprint │
                  └─────┬──────┘        └─────────┬────────┘
                        │                         │
               ┌───────┬┴───────┐         ┌───────┴────────┐
               │       │        │         │  4-Level       │
            TxID_0   TxID_1    ...        │  Year -> Tx -> │
               │                          │  Out -> Hash   │
        ┌──────┴───────┐                  └────────────────┘
        │   TxHeader   │
        │ ┌──────────┐ │
        │ │ HashBody │ │
        │ └─────┬────┘ │
        └───────┼──────┘
                │
        ┌───────┴─────────┐
        │                 │
    InputHash        OutputHash
        │                 │
   ┌────┴──────┐      BinaryTree
   │           │      (outputs)
LeadHash    RestHash
```

**Key invariants**：

- `TxID = SHA-512( TxHeader )` ——签名不参与。
- `HashBody = SHA-512( InputHash || OutputHash )` ——交易体完整性。
- `CheckRoot = SHA-512( TxTreeRoot || UTXOFingerprint )` ——区块完整性。
- 默认的哈希算法为 SHA-512，用于 TxID、交易体哈希、区块头哈希、哈希树等。
- UTXO 指纹基于应用当前区块交易 **before** 的 UTXO 集，采用 SHA3-512 哈希算法以与默认 SHA-512 区分。
- 附件指纹（对数据本体）采用 BLAKE3 可变长度哈希算法，以平衡速度与安全性需求。
- 附件的分片哈希树采用 SHA3-384，以提供高效且安全的分片验证。
- 公钥哈希采用 SHA3-384，以平衡空间占用和安全强度。
