# Proposal 4: Stack-Based Script System（栈式脚本系统设计提案）

## 1. Overview（概述）

Evidcoin 采用栈式脚本语言来控制信元（coins、vouchers、attestations）的锁定与解锁。脚本系统被设计为 **basically Turing-complete** ——支持完整的流程控制（IF/ELSE、SWITCH/CASE、EACH）、算术表达式、多数据类型与外部交互，同时施加严格资源约束以防滥用。

不同于以账户为中心的以太坊智能合约，本系统遵循 UTXO 模型：脚本嵌入交易输出（锁定脚本），并由对应输入（解锁脚本）满足。也不同于比特币刻意受限的 Script，Evidcoin 的脚本通过 **argument space** 机制、**local/global scopes**、**pattern matching** 与 **cross-script references**（GOTO/EMBED）提供更丰富的表达能力。

### Design Principles（设计原则）

- **Deterministic execution**：脚本执行期间只读；所有指令均预定义，不支持用户自定义函数。
- **Auditable**：没有自定义函数定义，使脚本结构更简单、易审计。
- **Resource-bounded**：对栈高度、数据项大小、脚本长度与循环次数设定固定上限，防止拒绝服务攻击。
- **Extensible**：四段式指令架构配套内建扩展机制，允许指令集增长而不破坏兼容性。


## 2. Execution Environment（执行环境）

### 2.1 Stack Machine Model（栈机器模型）

脚本引擎是栈式机器，按字节序列自始至终线性处理指令。核心运行时由以下组件构成：

```go
// ScriptEngine 脚本执行引擎的核心结构
type ScriptEngine struct {
    Stack      []any         // 数据栈（LIFO），最大高度 256
    ArgSpace   []any         // 实参区（FIFO 队列），一次性消费
    LocalScope []any         // 局部域，块级私有，容量 128
    GlobalVars [256]any      // 全局变量区，脚本域内共享
    InBuffer   []any         // 导入缓存区（FIFO）
    OutBuffer  []any         // 导出缓存区（FIFO）
    PassState  bool          // 通关状态
    Script     []byte        // 指令序列（只读）
    PC         int           // 程序计数器
}
```

**Data Stack**：`[]any` 的 LIFO 结构。指令从栈中取操作数并将返回值压回栈顶。最大高度 256。

**Argument Space**：FIFO 队列，用于将指令操作数顺序与栈位置解耦。指令需要实参时，系统优先读取实参区；仅当为空时才回退到栈。实参按原子方式（一次性）消费。

**Local Scope**：块级私有的追加式存储（容量 128）。每个语法块（`IF{}`、`EACH{}`、`BLOCK{}` 等）拥有独立局部域，彼此不可交叉引用。

**Global Variables**：当前脚本域共享的 256 槽数组，通过 `VAR`/`SETVAR` 指令访问。`GOTO` 边界不共享，但与 `EMBED` 脚本共享。

### 2.2 Argument Retrieval Rules（实参获取规则）

Each instruction is configured with an argument count specification:

| 配置 | 含义 |
|--------|---------|
| `0`    | 不需要实参；不读取实参区 |
| `n`    | 固定数量；优先从实参区消费，若实参区为空则从栈消费。实参区条目数量必须恰好匹配 |
| `-1`   | 可变数量；若实参区有值则消费之，否则不取值（不访问栈） |

该机制是脚本语言超越传统纯栈式设计的关键创新——它解决了传统栈语言固有的操作数顺序僵化问题。

### 2.3 Instruction Structure（指令结构）

字节流中的每条指令由以下部分组成：

```
[Opcode: 1 byte] [Auxiliary params: 0~N bytes] [Associated data: 0~N bytes]
```

- **Opcode**：1 字节指令标识（0–253 可用）。
- **Auxiliary Parameters**（附参）：描述指令本身的静态编译期参数（如 `IF{}` 的块长度、`FN_HASH256` 的哈希算法），固定长度或 varint。
- **Associated Data**（关联数据）：指令携带的负载（如 `IF{}` 内的代码块、`DATA{}` 的字节内容）。
- **Arguments**（实参）：运行时从实参区或数据栈消费的值——不属于指令的字节表示。

### 2.4 Environment Hierarchy（环境层级）

脚本执行环境按嵌套作用域组织：

```
System Domain  >  Transaction Domain  >  Validation Domain  >  Script Domain  >  Block Domain
  (节点环境)        (交易环境)             (校验环境)             (脚本环境)         (块域)
```

- **System Domain**：节点级运行时信息（链高、时间戳）。
- **Transaction Domain**：当前交易的输入、输出与源输出。
- **Validation Domain**：当前输出的校验上下文，包含 GOTO/EMBED 状态与计数器。
- **Script Domain**：脚本级环境（数据栈、实参区、全局变量）。每次 GOTO 会创建新的脚本域。
- **Block Domain**：语法块级局部域。对每个块私有，互不访问。


## 3. Instruction Set Architecture（指令集架构）

### 3.1 Four-Segment Layout（四段布局）

指令集在单字节 opcode 空间（0–253）内划分为四个连续区段：

| Segment | Range | Count | Description |
|---------|-------|-------|-------------|
| **Base Instructions**（基础指令段） | `[0–169]` | 170 | 核心语言：值、栈操作、流程控制、运算、比较、逻辑、模式匹配、环境访问、工具与系统调用 |
| **Function Instructions**（函数指令段） | `[170–209]` | 40 | 常用函数：编码、哈希、签名验证，外加 1 个自扩展槽（`FN_X`） |
| **Module Instructions**（模块指令段） | `[210–249]` | 40 | 分类模块：数学、时间、正则，外加 1 个自扩展槽（`MO_X`） |
| **Extension Instructions**（扩展指令段） | `[250–253]` | 4 | 通用扩展点：`EX_FN`、`EX_MO`、`EX_INST`、`EX_PRIV`（2 字节索引，各自可寻址 64K） |

Opcode 254 与 255 保留给系统，不属于指令集。

### 3.2 Base Instruction Categories（基础指令分类）

170 条基础指令按功能分类：

| 类别 | 范围 | 数量 | 关键指令 |
|----------|-------|-------|-----------------|
| Value Instructions（值指令） | `[0–19]` | 20 | `NIL`, `TRUE`, `FALSE`, `DATA{}`, `CODE{}`, `SCRIPT`, `VALUE{}`, 整数/浮点/字符串/正则/日期字面量 |
| Capture Instructions（截取指令） | `[20–24]` | 5 | `@`（实参捕获），`~`（直接栈），`$`（本地存储），`$()`（本地读取），`$X()`（循环变量） |
| Stack Operations（栈操作指令） | `[25–35]` | 11 | `NOP`, `PUSH`, `POP`, `TOP`, `PEEK`, `SHIFT`, `CLONE`, `VIEW` |
| Collection Operations（集合指令） | `[36–45]` | 10 | `SLICE`, `REVERSE`, `MERGE`, `EXTEND`, `PACK`, `SPREAD`, `SET`, `ITEM`, `INDEX`, `SIZE` |
| Interaction Instructions（交互指令） | `[46–49]` | 4 | `INPUT`, `OUTPUT`, `BUFDUMP`, `PRINT` |
| Result Instructions（结果指令） | `[50–56]` | 7 | `PASS`, `CHECK`, `GOTO`, `EMBED`, `EXIT`, `RETURN`, `END` |
| Flow Control（流程控制） | `[57–66]` | 10 | `IF{}`, `ELSE{}`, `SWITCH{}`, `CASE{}`, `DEFAULT{}`, `EACH{}`, `CONTINUE`, `BREAK`, `BLOCK{}` |
| Conversion Instructions（转换指令） | `[67–79]` | 13 | `BOOL`, `BYTE`, `INT`, `FLOAT`, `STRING`, `BYTES`, `TIME`, `REGEXP`, `DICT`, `ANYS` |
| Arithmetic Instructions（运算指令） | `[80–103]` | 24 | 表达式 `()`, `+`, `-`, `*`, `/`, `%`, `MUL`, `ADD`, `POW`, 位运算, `REP`, `DEL` |
| Comparison Instructions（比较指令） | `[104–111]` | 8 | `EQUAL`, `NEQUAL`, `LT`, `LTE`, `GT`, `GTE`, `ISNAN`, `WITHIN` |
| Logic Instructions（逻辑指令） | `[112–115]` | 4 | `BOTH` (&&), `EITHER` (\|\|), `EVERY`, `SOME(n)` |
| Pattern Instructions（模式指令） | `[116–127]` | 12 | `MODEL{}`, `_`, `_()`, `?{}`, `?()`, `#()`, `!{}`, `RE{}`, `&()`, `...` |
| Environment Instructions（环境指令） | `[128–137]` | 10 | `ENV{}`, `IN{}`, `OUT{}`, `INOUT{}`, `XFROM{}`, `VAR`, `SETVAR`, `SOURCE`, `MULSIG` |
| Tool Instructions（工具指令） | `[138–163]` | 26 | `EVAL`, `COPY`, `MATCH`, `RANGE`, `MAP{}`, `FILTER{}`, `EGO{}`, `SHELL{}`，+ 8 保留（量子安全） |
| System Instructions（系统指令） | `[164–169]` | 6 | `SYS_TIME{}`, `SYS_AWARD`, `SYS_CHKPASS`, `SYS_NULL` |

### 3.3 Instruction Naming Conventions（指令命名约定）

指令按五类命名规则分组以便视觉识别：

| 类别 | 前缀 | 示例 |
|----------|--------|----------|
| 基础功能 | *(none)* | `PASS`, `IF`, `TRUE`, `EQUAL` |
| 系统调用 | `SYS_` | `SYS_TIME{}`, `SYS_CHKPASS` |
| 函数 | `FN_` | `FN_CHECKSIG`, `FN_PUBHASH`, `FN_HASH256` |
| 模块 | `MO_` | `MO_MATH{}`, `MO_TIME{}`, `MO_RE{}` |
| 扩展 | `EX_` | `EX_FN`, `EX_INST`, `EX_PRIV` |


## 4. Key Instruction Details（关键指令详解）

### 4.1 PASS — Gate Check（通关检查）

`PASS` 是基础校验原语，从栈（或实参区）取布尔值：

- **true**：将通关状态置为 PASS，继续执行。
- **false**：将通关状态置为 FAIL，脚本立即终止。

多个 `PASS` 指令等同逻辑 AND——每一道门都必须成功。这是锁定脚本校验的主要机制。

```go
// 单签名标准验证流程
// Unlock script:
<sig>                   // 签名入栈
<pubKey>                // 公钥入栈

// Lock script:
TOP                     // 引用栈顶（公钥副本）
FN_PUBHASH              // 计算公钥哈希
DATA{<expected_hash>}   // 预置的公钥哈希
EQUAL PASS              // 哈希相等时通过（Gate 1）
FN_CHECKSIG PASS        // 签名验证通过（Gate 2）
```

配套指令 `CHECK` 类似，但失败时不会终止——只设置通关状态，且可被后续 `CHECK` 覆盖（类似逻辑 OR）。

### 4.2 GOTO — Independent Jump（独立跳转）

`GOTO` 将执行重定向到另一笔交易的输出脚本。目标脚本运行于 **independent sub-environment**，拥有独立的数据栈、实参区与全局变量，但与调用者共享导入/导出缓冲区。

```go
52      GOTO(~,64,~)    // 独立跳转
        // 附参1：交易年度（varint）
        // 附参2：交易 ID（64 bytes）
        // 附参3：输出项序位（varint）
```

**Execution semantics:**

1. 实参区内容转移为目标脚本的初始栈内容。
2. 目标脚本在自有环境中执行，但继承校验上下文。
3. 目标脚本的 PASS/FAIL 结果回写到最上层调用者的通关状态。
4. 目标脚本的数据栈在退出时丢弃——临时有效。
5. 调用者与被调用者共享导入/导出缓冲区。

**GOTO vs EMBED comparison:**

| 方面 | GOTO | EMBED |
|--------|------|-------|
| 环境 | Independent（新栈、实参区、全局变量） | Merged（共享调用者栈、实参区、全局变量） |
| 通关状态 | 回写给调用者 | 直接影响当前脚本 |
| 最大次数 | 主脚本层 ≤ 2 | 运行时总计 ≤ 4 |
| 最大深度 | 运行时 ≤ 3 | 深度 0（嵌入脚本内不可嵌套 EMBED/GOTO） |
| 数据共享 | 通过实参区转移 | 完全共享环境 |

### 4.3 SYS_CHKPASS — Built-in Verification（系统内置验证）

执行标准签名验证（单签或多签）的专用系统指令。与其他指令不同，其参数来自 **environment** 而非数据栈：

```go
// SYS_CHKPASS 函数签名（概念上）：
SYS_CHKPASS(sigType, authFlag, []sigs, []pubKeys, []pubKeyHashes)
// sigType: 1=单签, 2=多签
// 末尾的 []pubKeyHashes 仅在多签时使用
```

该指令同样是门指令——验证失败即终止执行。设计上将签名数据与数据栈分离，以避免签名进入交易 ID 计算，便于后续裁剪签名。

### 4.4 Cryptographic Functions（密码学函数）

| 指令 | 描述 |
|-------------|-------------|
| `FN_HASH224(algo)` | 哈希到 224 位（sha3/sha2/blake2） |
| `FN_HASH256(algo)` | 哈希到 256 位（sha3/sha2/blake2） |
| `FN_HASH384(algo)` | 哈希到 384 位（sha3/sha2/blake2） |
| `FN_HASH512(algo)` | 哈希到 512 位（sha3/sha2/blake2），链上默认 |
| `FN_PUBHASH` | 计算公钥哈希，或解码账户地址 |
| `FN_MPUBHASH` | 计算多签复合公钥哈希 |
| `FN_CHECKSIG` | 单签验证 → Bool |
| `FN_MCHECKSIG` | 多签验证 → Bool |
| `FN_ADDRESS` | 将公钥哈希编码为可读地址（Base58） |

默认哈希算法：SHA-3（FIPS-202）。附件使用 BLAKE3。

### 4.5 Flow Control（流程控制）

#### IF/ELSE

```go
// 条件分支
<condition_value>       // 布尔值入栈
IF {
    // 条件为真时执行
}
ELSE {
    // 条件为假时执行
}
// IF 和 ELSE 之间可以插入其他指令
```

`IF` 消费一个布尔实参。`ELSE` 检查同一块级最近一次 `IF` 的状态。同层多个 IF 会互相覆盖状态。

#### SWITCH/CASE

```go
{target_value}          // 标的值
{case1, case2, case3}   // 分支值列表
SWITCH {
    CASE { ... }        // case1 匹配时执行
    CASE { ... }        // case2 匹配时执行
    CASE { ... }        // case3 匹配时执行
    DEFAULT { ... }     // 无匹配时执行
}
```

只执行第一个匹配的 CASE 块，随后退出 SWITCH。

#### EACH — Bounded Iteration（有限循环）

```go
{1, 3, 5, 7}           // 迭代目标集
EACH {
    $Value PUSH         // 入栈当前条目值
    // 循环变量通过 $Value, $Index/$Key, $Slice/$Dict, $Size 访问
}
```

脚本系统 **no unbounded loop**。`EACH` 仅遍历有限集合（slice 或 dict），循环体支持 `BREAK` 与 `CONTINUE`。

### 4.6 Pattern Matching（模式匹配）

`MODEL{}` 指令创建模式匹配上下文，用于验证目标脚本是否符合特定结构。这对跨链交换等场景尤为关键，双方需要验证彼此的支付脚本。

```go
// 验证目标脚本是否为标准支付脚本
CODE{<target_script>}
MODEL {
    SYS_CHKPASS                     // 严格匹配
    SYS_TIME{Stamp} {?} #[32] GT   // 时间戳任意，提取值
    IF {
        MULSIG[0] PASS              // 严格匹配
        EXIT                        // 严格匹配
    }
    MULSIG[1] PASS                  // 严格匹配
    FN_HASH256                      // 严格匹配
    DATA[32]{?} #[32]               // 数据长度32字节，内容任意，提取值
    EQUAL PASS                      // 严格匹配
}
// Returns: ([timestamp, hashResult], Bool)
```

模式指令支持：
- **Exact matching**：`MODEL{}` 中普通指令必须精确匹配。
- **Wildcards**：`_`（单条指令）、`_[n]`（n 条指令）、`...`（零条或多条指令）。
- **Optional matching**：`?{}` 序列可有可无。
- **Type matching**：`!Bool`、`!Int`、`!Bytes` 等。
- **Value extraction**：`#(bits)` 提取匹配指令的特定部分。
- **Range constraints**：`!{min, max}` 用于整数/浮点范围匹配。
- **Regex matching**：`RE{/.../}` 在 MODEL 内对文本/字节序列进行正则匹配。

### 4.7 External Interaction（外部交互）

脚本通过两个独立的缓冲队列与外部交互：

```go
// 导出（非阻塞）
@POPS[3] OUTPUT     // 弹出栈顶3项 → 导出缓存区
BUFDUMP[tag]        // 触发外部监听器，清空导出缓存区

// 导入（阻塞）
INPUT[3]            // 从导入缓存区取3项 → 入栈
                    // 缓存区无数据时：失败但正常退出
```

**Export** 为非阻塞：外部监听器注册处理器，导出触发事件分发，用于链下业务逻辑。

**Import** 为阻塞：若缓冲区为空或数据不足，执行以可恢复方式失败（保留通关状态）。对公共校验节点，`INPUT` 等同隐式 `END`。


## 5. Locking and Unlocking Flow（锁定与解锁执行流程）

### 5.1 Script Execution Pipeline（脚本执行管道）

当交易输入引用先前输出时，校验流程如下：

```graph
┌─────────────────────────────────────────────────────────┐
│ 1. Load unlock data into environment                    │
│    (sigType, authFlag, signatures, pubKeys, pubHashes)  │
├─────────────────────────────────────────────────────────┤
│ 2. Execute unlock script                                │
│    - Restricted to opcodes [0-49]                       │
│    - Primarily pushes values onto the data stack        │
├─────────────────────────────────────────────────────────┤
│ 3. Execute lock script                                  │
│    - Full instruction set available                     │
│    - Consumes values from the stack                     │
│    - Must achieve PASS state                            │
├─────────────────────────────────────────────────────────┤
│ 4. Check pass-state                                     │
│    - PASS: validation succeeds, UTXO can be spent       │
│    - FAIL: validation fails, transaction rejected       │
└─────────────────────────────────────────────────────────┘
```

### 5.2 Unlock Script Restrictions（解锁脚本限制）

解锁脚本仅允许 opcode `[0–49]`：
- 值指令（将数据入栈）
- 截取指令（实参区操作）
- 栈操作指令（重排）
- 集合指令（基础结构处理）
- 交互指令（导入/导出）

这可防止解锁脚本包含诸如 `TRUE PASS EXIT` 的逻辑从而轻易绕过锁定。实践中解锁脚本主要是“数据”——它们提供锁定脚本需要验证的值。

### 5.3 Standard Payment Example（标准支付示例）

**Single-signature coin payment:**

```go
// 解锁数据 → 载入环境
// {1}          签名方法（单签）
// <flag>       授权标记
// <sig>        签名数据
// <pubKey>     公钥

// 锁定脚本
SYS_CHKPASS     // 系统内置验证：
                // 从环境取实参 (1, flag, sig, pubKey, receiver)
                // 验证签名，成功则 PASS
```

**Hash-barrier payment (e.g., for cross-chain exchange):**

```go
// 解锁脚本
<hashSource>            // 哈希原像入栈

// 锁定脚本
SYS_CHKPASS             // 签名验证
TOP                     // 复制栈顶（哈希原像）
FN_HASH256              // 计算哈希
DATA{<expected_hash>}   // 预置的哈希目标
EQUAL PASS              // 哈希屏障验证
END                     // 公共验证结束
@POP OUTPUT BUFDUMP     // 私有逻辑：导出哈希原像
```


## 6. Basic Turing Completeness（基本图灵完备性）

### 6.1 Capabilities（能力）

脚本系统通过以下机制实现“基本图灵完备性”：

| 能力 | 实现方式 |
|------------|---------------|
| **Sequential execution** | 线性指令处理 |
| **Conditional branching** | `IF{}`, `ELSE{}`, `SWITCH/CASE{}` |
| **Bounded iteration** | `EACH{}` 遍历有限集合，`MAP{}`、`FILTER{}` |
| **Arithmetic** | 完整算术运算、表达式语法 `()`、位运算 |
| **Data types** | Bool, Byte, Rune, Int, BigInt, Float, String, Bytes, RegExp, Time, Script, Dict |
| **Memory** | 数据栈、实参区、局部域、全局变量 |
| **Subroutines** | `GOTO`（独立）、`EMBED`（合并）、`EVAL`（隔离） |
| **Pattern matching** | `MODEL{}` 进行脚本结构校验 |
| **External I/O** | `INPUT`/`OUTPUT`/`BUFDUMP` 链下交互 |

### 6.2 Bounded by Design（有界设计）

系统被刻意约束以确保资源消耗可预测：

- **No infinite loops**：仅有 `EACH`（遍历有限集合）及有界 `MAP`/`FILTER`。
- **No recursion**：GOTO 深度限制为 3，EMBED 深度为 0；不存在回调同一脚本的指令。
- **No self-modification**：脚本执行期间只读。
- **Fixed stack capacity**：最大 256 项，防止内存无限增长。
- **No dynamic code generation**：`CODE{}` 仅生成惰性数据，只有 `EVAL` 可执行，且在完全隔离环境中运行。

因此系统在有界条件下具备实用上的图灵完备性（可表达任意有界计算），并保证终止与资源有界——这是区块链执行环境的有意折中。


## 7. Security Constraints（安全约束）

### 7.1 Runtime Limits（运行时限制）

| 参数 | 限制 | 理由 |
|-----------|-------|-----------|
| 栈高度 | < 256 | 大多数数据会立刻被消费，深栈往往是滥用信号 |
| 栈项大小 | < 1 KB | 防止超大数据条目 |
| 锁定脚本长度 | < 1 KB | 约束锁逻辑复杂度 |
| 解锁脚本长度 | < 4 KB | 允许足量解锁数据（不含标准签名数据） |
| 交易大小 | < 400 KB | 不含解锁部分 |
| 单笔输出数量 | < 1024 | 单字节 7 位表达（128×8） |
| EMBED 调用 | ≤ 4 | 运行时计数，含子脚本嵌入 |
| EMBED 深度 | = 0 | 嵌入脚本不能继续 EMBED 或 GOTO |
| GOTO 调用 | ≤ 2 | 主脚本层运行时计数 |
| GOTO 深度 | ≤ 3 | 运行时计数；设计参考：manager + auditor + third-party |
| 解锁脚本 opcode | 仅 `[0–49]` | 防止绕过攻击 |

### 7.2 Block Size Limits（区块容量限制）

区块容量按阶段增长以支持网络扩展：

| 阶段 | 区块容量上限 |
|--------|-----------------|
| 第 1–3 个月（21,915 区块） | 固定 1 MB |
| 第 4–36 个月 | 每月 +1 MB（最多 34 MB） |
| 第 4 年起（87,661 区块/年） | 每年 +2 MB |

区块容量包含解锁部分（不含标准签名数据）。

### 7.3 Script Immutability（脚本不可变性）

- 脚本执行期间 **read-only**。执行修改的指令（如集合修改）作用于副本。
- `EVAL` 提供隔离执行——内部脚本的通关状态不影响调用者。
- `SOURCE` 返回脚本字节序列副本，而非活引用。

### 7.4 Extension Security（扩展安全性）

- `EX_PRIV`（私有扩展）被公共校验节点忽略——仅用于私有应用逻辑。
- `EGO{}` 与 `SHELL{}`（嵌入 Go/Shell 代码）只在存证识别脚本中生效；在币金/凭信上下文中被校验节点忽略。
- `Bytes` 到 `Script` 类型不存在转换路径——防止任意代码注入。


## 8. Type System（类型系统）

### 8.1 Supported Types（支持的类型）

```go
// 基础类型
type Nil    = nil           // 空值
type Bool   = bool          // 布尔值
type Byte   = uint8         // 单字节
type Rune   = rune          // Unicode 码点 (int32)
type Int    = int64         // 64位整数
type BigInt = *big.Int      // 任意精度整数
type Float  = float64       // 64位浮点数
type String = string        // UTF-8 字符串
type Bytes  = []byte        // 字节序列
type RegExp = *regexp.Regexp // 正则表达式
type Time   = time.Time     // 时间对象
type Script = []byte        // 指令序列（特殊类型标记）

// 复合类型
type Slice  = []any         // 通用切片
type Dict   = map[string]any // 字典
```

### 8.2 Type Promotion（类型提升）

创建值集合 `{...}` 时，类型按以下路径自动提升：

```
Byte → Rune → Int → BigInt
Byte → Rune → Int → Float
```

Float 与 String 为终止类型——不可继续提升。

### 8.3 Conversion Instructions（转换指令）

显式类型转换由专用指令提供：`BOOL`、`BYTE`、`RUNE`、`INT`、`BIGINT`、`FLOAT`、`STRING`、`BYTES`、`RUNES`、`TIME`、`REGEXP`、`DICT`、`ANYS`。

**Security note**：刻意不支持 `Bytes` 到 `Script` 的转换，以防代码注入攻击。


## 9. Cross-Script References（跨脚本引用）

脚本系统支持三种外部脚本引用机制：

### 9.1 SCRIPT — Value Reference（值引用）

```go
18  SCRIPT(~,64,~)  // 附参：年度, 交易ID, 输出序位
```

将目标交易输出脚本作为 `Script` 值加载到栈上。脚本 **not executed**——它是可被哈希、模式匹配或与 `EVAL` 配合使用的数据。

### 9.2 GOTO — Independent Execution（独立执行）

```go
52  GOTO(~,64,~)    // 独立跳转到外部脚本
```

创建新的脚本域并执行目标脚本，详见第 4.2 节。

### 9.3 EMBED — Merged Execution（合并执行）

```go
53  EMBED(~,64,~)   // 嵌入外部脚本
```

将目标脚本注入当前执行上下文。嵌入脚本与调用者共享数据栈、实参区与全局变量。这是 **merge** 操作——相当于将嵌入指令直接内联。

**Constraint**: Embedded scripts cannot contain further `EMBED` or `GOTO` instructions (depth = 0).


## 10. Notation Conventions（书写约定）

用于人类可读的脚本表示：

| 符号 | 含义 |
|--------|---------|
| `{}`   | 关联数据（代码块、值） |
| `[]`   | 附参（默认时可省略） |
| `()`   | 文档中：附参字节长度 |
| `<>`   | 命名数据占位（如 `<pubKey>`、`<sig>`） |

反编译字节码的 **Display rules**：
- 子块使用缩进。
- 长值（`DATA{}`、大整数、正则）单独成行。
- 结果指令（`PASS`、`RETURN`、`EXIT`）位于行尾。
- 捕获前缀（`@`、`~`、`$`）紧贴目标指令。

### Source format example:

```go
SYS_CHKPASS
SYS_TIME{Stamp} {<expireTime>} GT
IF {
    MULSIG[0] PASS
    EXIT
}
MULSIG[1] PASS
FN_HASH256
DATA{<hashResult>}
EQUAL PASS
END

@POP OUTPUT BUFDUMP
```


## 11. Application Scenarios（应用场景）

脚本系统通过原语组合支持多样化用例：

| 场景 | 关键机制 |
|----------|---------------|
| **Standard payment** | `SYS_CHKPASS` (single/multi-sig) |
| **Hash-barrier payment** | `FN_HASH256` + `DATA{}` + `EQUAL PASS` |
| **Time-locked redemption** | `SYS_TIME{Stamp}` + `IF{}` + `MULSIG` |
| **Cross-chain exchange** | Hash barriers + time locks + `MODEL{}` pattern verification + `OUTPUT`/`BUFDUMP` |
| **Escrow with expiry** | Multi-sig + time condition + hash barrier |
| **Script verification** | `MODEL{}` pattern matching for structural validation |
| **Off-chain coordination** | `OUTPUT`/`BUFDUMP` for event-driven middleware |
| **Voucher transfer** | `SYS_CHKPASS` with credit-specific validation logic |
| **Attestation identification** | `EGO{}`/`SHELL{}` for programmatic recognition |


## 12. Summary（总结）

Evidcoin 栈式脚本系统通过以下方面在表达力与安全性之间取得平衡：

1. **Decoupled operand ordering** 通过实参区机制解耦操作数顺序，克服传统栈语言的僵化。
2. **Comprehensive control flow**（IF/ELSE、SWITCH/CASE、EACH）在有界资源下提供基本图灵完备性。
3. **Four-segment extensible architecture** 使指令集从 170+ 基础指令扩展到理论上无限。
4. **Pattern matching**（`MODEL{}`）实现无信任跨脚本结构校验，是跨链与自动化流程的独特能力。
5. **Strict resource bounds** 确保确定性执行并防止拒绝服务攻击。
6. **Clean separation** 在解锁数据（受限 opcode [0–49]）与锁定逻辑（完整指令集）之间保持清晰分离，维持安全不变量。
7. **External interaction** 通过缓冲 I/O 连接链上校验与链下业务流程。
