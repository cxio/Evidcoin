# Proposal 4: Stack-Based Script System（栈式脚本系统设计提案）

## 1. Overview（概述）

Evidcoin employs a stack-based scripting language that governs how evidence units (coins, vouchers, and attestations) are locked and unlocked. The script system is designed to be **basically Turing-complete** — it supports full flow control (IF/ELSE, SWITCH/CASE, EACH), arithmetic expressions, multiple data types, and external interaction, while imposing strict resource constraints to prevent abuse.

Unlike Ethereum's account-based smart contracts, this system follows the UTXO model: scripts are embedded in transaction outputs (locking scripts) and must be satisfied by corresponding inputs (unlocking scripts). Unlike Bitcoin's deliberately limited Script, Evidcoin's scripting offers richer expressiveness through an **argument space** mechanism, **local/global scopes**, **pattern matching**, and **cross-script references** (GOTO/EMBED).

### Design Principles（设计原则）

- **Deterministic execution**: Scripts are read-only during execution; all instructions are pre-defined with no user-defined functions.
- **Auditable**: The absence of custom function definitions makes scripts structurally simple and easy to audit.
- **Resource-bounded**: Fixed limits on stack height, data item size, script length, and loop iterations prevent denial-of-service attacks.
- **Extensible**: A four-segment instruction architecture with built-in extension mechanisms allows the instruction set to grow without breaking compatibility.


## 2. Execution Environment（执行环境）

### 2.1 Stack Machine Model（栈机器模型）

The script engine is a stack machine that processes an instruction byte sequence linearly from start to end. The core runtime consists of the following components:

```go
// ScriptEngine 脚本执行引擎的核心结构
type ScriptEngine struct {
    Stack      []any         // 数据栈（LIFO），最大高度 256
    ArgSpace   []any         // 实参区（FIFO 队列），一次性消费
    LocalScope []any         // 局部域，块级私有，容量 128
    GlobalVars [256]any      // 全局变量区，脚本域内共享
    InBuffer   []any         // 导入缓存区（FIFO）
    OutBuffer  []any         // 导出缓存区（FIFO）
    PassState  bool          // 通关状态
    Script     []byte        // 指令序列（只读）
    PC         int           // 程序计数器
}
```

**Data Stack**: A `[]any` LIFO structure. Instructions consume operands from the stack and push return values back. Maximum height is 256 entries.

**Argument Space**: A FIFO queue that decouples instruction operand ordering from stack position. When an instruction requires arguments, the system first checks the argument space; only if it is empty does it fall back to the stack. Arguments are consumed atomically (all-at-once).

**Local Scope**: A block-private append-only storage (capacity 128). Each syntax block (`IF{}`, `EACH{}`, `BLOCK{}`, etc.) has its own isolated local scope. Scopes cannot cross-reference each other.

**Global Variables**: A 256-slot array shared within the current script domain. Accessible via `VAR`/`SETVAR` instructions. Not shared across `GOTO` boundaries, but shared with `EMBED`-ed scripts.

### 2.2 Argument Retrieval Rules（实参获取规则）

Each instruction is configured with an argument count specification:

| Config | Meaning |
|--------|---------|
| `0`    | No arguments needed; argument space is not read |
| `n`    | Fixed count; consumed from argument space first, then from stack if argument space is empty. Argument space entry count must match exactly |
| `-1`   | Variable count; if argument space has values, consume them; otherwise take nothing (does not access the stack) |

This mechanism is the key innovation that elevates the scripting language beyond simple stack-only designs — it resolves the rigid operand ordering problem inherent in traditional stack languages.

### 2.3 Instruction Structure（指令结构）

Every instruction in the byte stream consists of:

```
[Opcode: 1 byte] [Auxiliary params: 0~N bytes] [Associated data: 0~N bytes]
```

- **Opcode**: 1-byte instruction identifier (0–253 usable).
- **Auxiliary Parameters** (附参): Static, compile-time parameters that describe the instruction itself (e.g., block length for `IF{}`, hash algorithm for `FN_HASH256`). Fixed-size or varint.
- **Associated Data** (关联数据): Payload carried by the instruction (e.g., the code block inside `IF{}`, the byte content of `DATA{}`).
- **Arguments** (实参): Runtime values consumed from the argument space or data stack — NOT part of the instruction's byte representation.

### 2.4 Environment Hierarchy（环境层级）

The script execution environment is organized in nested scopes:

```
System Domain  >  Transaction Domain  >  Validation Domain  >  Script Domain  >  Block Domain
  (节点环境)        (交易环境)             (校验环境)             (脚本环境)         (块域)
```

- **System Domain**: Node-level runtime information (chain height, timestamps).
- **Transaction Domain**: The current transaction's inputs, outputs, and source outputs.
- **Validation Domain**: The current output's verification context, including GOTO/EMBED state and counters.
- **Script Domain**: Script-level environment (data stack, argument space, global variables). Each GOTO creates a new script domain.
- **Block Domain**: Syntax block-level local scope. Private to each block, no cross-access.


## 3. Instruction Set Architecture（指令集架构）

### 3.1 Four-Segment Layout（四段布局）

The instruction set is organized into four contiguous segments within a single-byte opcode space (0–253):

| Segment | Range | Count | Description |
|---------|-------|-------|-------------|
| **Base Instructions**（基础指令段） | `[0–169]` | 170 | Core language: values, stack ops, flow control, arithmetic, comparison, logic, pattern matching, environment access, tools, system calls |
| **Function Instructions**（函数指令段） | `[170–209]` | 40 | Commonly used functions: encoding, hashing, signature verification, plus 1 self-extension slot (`FN_X`) |
| **Module Instructions**（模块指令段） | `[210–249]` | 40 | Categorized modules: math, time, regex, plus 1 self-extension slot (`MO_X`) |
| **Extension Instructions**（扩展指令段） | `[250–253]` | 4 | Generic extension points: `EX_FN`, `EX_MO`, `EX_INST`, `EX_PRIV` (2-byte index, 64K addressable each) |

Opcodes 254 and 255 are reserved by the system and not part of the instruction set.

### 3.2 Base Instruction Categories（基础指令分类）

The 170 base instructions are organized by function:

| Category | Range | Count | Key Instructions |
|----------|-------|-------|-----------------|
| Value Instructions（值指令） | `[0–19]` | 20 | `NIL`, `TRUE`, `FALSE`, `DATA{}`, `CODE{}`, `SCRIPT`, `VALUE{}`, integer/float/string/regex/date literals |
| Capture Instructions（截取指令） | `[20–24]` | 5 | `@` (arg capture), `~` (direct stack), `$` (local store), `$()` (local read), `$X()` (loop var) |
| Stack Operations（栈操作指令） | `[25–35]` | 11 | `NOP`, `PUSH`, `POP`, `TOP`, `PEEK`, `SHIFT`, `CLONE`, `VIEW` |
| Collection Operations（集合指令） | `[36–45]` | 10 | `SLICE`, `REVERSE`, `MERGE`, `EXTEND`, `PACK`, `SPREAD`, `SET`, `ITEM`, `INDEX`, `SIZE` |
| Interaction Instructions（交互指令） | `[46–49]` | 4 | `INPUT`, `OUTPUT`, `BUFDUMP`, `PRINT` |
| Result Instructions（结果指令） | `[50–56]` | 7 | `PASS`, `CHECK`, `GOTO`, `EMBED`, `EXIT`, `RETURN`, `END` |
| Flow Control（流程控制） | `[57–66]` | 10 | `IF{}`, `ELSE{}`, `SWITCH{}`, `CASE{}`, `DEFAULT{}`, `EACH{}`, `CONTINUE`, `BREAK`, `BLOCK{}` |
| Conversion Instructions（转换指令） | `[67–79]` | 13 | `BOOL`, `BYTE`, `INT`, `FLOAT`, `STRING`, `BYTES`, `TIME`, `REGEXP`, `DICT`, `ANYS` |
| Arithmetic Instructions（运算指令） | `[80–103]` | 24 | Expression `()`, `+`, `-`, `*`, `/`, `%`, `MUL`, `ADD`, `POW`, bit ops, `REP`, `DEL` |
| Comparison Instructions（比较指令） | `[104–111]` | 8 | `EQUAL`, `NEQUAL`, `LT`, `LTE`, `GT`, `GTE`, `ISNAN`, `WITHIN` |
| Logic Instructions（逻辑指令） | `[112–115]` | 4 | `BOTH` (&&), `EITHER` (\|\|), `EVERY`, `SOME(n)` |
| Pattern Instructions（模式指令） | `[116–127]` | 12 | `MODEL{}`, `_`, `_()`, `?{}`, `?()`, `#()`, `!{}`, `RE{}`, `&()`, `...` |
| Environment Instructions（环境指令） | `[128–137]` | 10 | `ENV{}`, `IN{}`, `OUT{}`, `INOUT{}`, `XFROM{}`, `VAR`, `SETVAR`, `SOURCE`, `MULSIG` |
| Tool Instructions（工具指令） | `[138–163]` | 26 | `EVAL`, `COPY`, `MATCH`, `RANGE`, `MAP{}`, `FILTER{}`, `EGO{}`, `SHELL{}`, + 8 reserved (quantum safety) |
| System Instructions（系统指令） | `[164–169]` | 6 | `SYS_TIME{}`, `SYS_AWARD`, `SYS_CHKPASS`, `SYS_NULL` |

### 3.3 Instruction Naming Conventions（指令命名约定）

Instructions are grouped into five naming categories for visual distinction:

| Category | Prefix | Examples |
|----------|--------|----------|
| Basic functionality | *(none)* | `PASS`, `IF`, `TRUE`, `EQUAL` |
| System calls | `SYS_` | `SYS_TIME{}`, `SYS_CHKPASS` |
| Functions | `FN_` | `FN_CHECKSIG`, `FN_PUBHASH`, `FN_HASH256` |
| Modules | `MO_` | `MO_MATH{}`, `MO_TIME{}`, `MO_RE{}` |
| Extensions | `EX_` | `EX_FN`, `EX_INST`, `EX_PRIV` |


## 4. Key Instruction Details（关键指令详解）

### 4.1 PASS — Gate Check（通关检查）

`PASS` is the fundamental verification primitive. It consumes a boolean from the stack (or argument space):

- **true**: Sets pass-state to PASS, execution continues.
- **false**: Sets pass-state to FAIL, script terminates immediately.

Multiple `PASS` instructions act as logical AND — every gate must succeed. This is the primary mechanism for locking script validation.

```go
// 单签名标准验证流程
// Unlock script:
<sig>                   // 签名入栈
<pubKey>                // 公钥入栈

// Lock script:
TOP                     // 引用栈顶（公钥副本）
FN_PUBHASH              // 计算公钥哈希
DATA{<expected_hash>}   // 预置的公钥哈希
EQUAL PASS              // 哈希相等时通过（Gate 1）
FN_CHECKSIG PASS        // 签名验证通过（Gate 2）
```

The companion instruction `CHECK` is similar but does NOT terminate on failure — it merely sets the pass-state, which can be overwritten by subsequent `CHECK` calls (acting like logical OR).

### 4.2 GOTO — Independent Jump（独立跳转）

`GOTO` redirects execution to a script located in another transaction's output. The target script runs in an **independent sub-environment** with its own data stack, argument space, and global variables, but shares import/export buffers with the caller.

```go
52      GOTO(~,64,~)    // 独立跳转
        // 附参1：交易年度（varint）
        // 附参2：交易 ID（64 bytes）
        // 附参3：输出项序位（varint）
```

**Execution semantics:**

1. Argument space contents are transferred as the target script's initial stack contents.
2. The target script executes with its own environment but inherits the validation context.
3. The target script's PASS/FAIL result is written back to the top-caller's pass-state.
4. The target script's data stack is discarded upon exit — it is temporary.
5. Import/export buffers are shared between caller and callee.

**GOTO vs EMBED comparison:**

| Aspect | GOTO | EMBED |
|--------|------|-------|
| Environment | Independent (new stack, arg space, globals) | Merged (shares caller's stack, arg space, globals) |
| Pass-state | Written back to caller | Direct effect on current script |
| Max count | ≤ 2 at main script level | ≤ 4 total (runtime count) |
| Max depth | ≤ 3 (runtime count) | Depth 0 (no nested EMBED/GOTO in embedded script) |
| Data sharing | Via argument space transfer | Full environment sharing |

### 4.3 SYS_CHKPASS — Built-in Verification（系统内置验证）

A specialized system instruction that performs standard signature verification (single-sig or multi-sig). Unlike other instructions, its arguments are extracted from the **environment** rather than the data stack:

```go
// SYS_CHKPASS 函数签名（概念上）：
SYS_CHKPASS(sigType, authFlag, []sigs, []pubKeys, []pubKeyHashes)
// sigType: 1=单签, 2=多签
// 末尾的 []pubKeyHashes 仅在多签时使用
```

This instruction is also a gate — it terminates execution on verification failure. The design separates signature data from the data stack to keep signatures out of the transaction ID calculation, facilitating later signature pruning.

### 4.4 Cryptographic Functions（密码学函数）

| Instruction | Description |
|-------------|-------------|
| `FN_HASH224(algo)` | Hash to 224 bits (sha3/sha2/blake2) |
| `FN_HASH256(algo)` | Hash to 256 bits (sha3/sha2/blake2) |
| `FN_HASH384(algo)` | Hash to 384 bits (sha3/sha2/blake2) |
| `FN_HASH512(algo)` | Hash to 512 bits (sha3/sha2/blake2), default for chain operations |
| `FN_PUBHASH` | Compute public key hash, or decode account address |
| `FN_MPUBHASH` | Compute composite multi-sig public key hash |
| `FN_CHECKSIG` | Single signature verification → Bool |
| `FN_MCHECKSIG` | Multi-signature verification → Bool |
| `FN_ADDRESS` | Encode public key hash to human-readable address (Base58) |

Default hash algorithm: SHA-3 (FIPS-202). Attachments use BLAKE3.

### 4.5 Flow Control（流程控制）

#### IF/ELSE

```go
// 条件分支
<condition_value>       // 布尔值入栈
IF {
    // 条件为真时执行
}
ELSE {
    // 条件为假时执行
}
// IF 和 ELSE 之间可以插入其他指令
```

`IF` consumes a boolean argument. `ELSE` checks the state of the most recent `IF` at the same block level. Multiple IFs at the same level override each other's state.

#### SWITCH/CASE

```go
{target_value}          // 标的值
{case1, case2, case3}   // 分支值列表
SWITCH {
    CASE { ... }        // case1 匹配时执行
    CASE { ... }        // case2 匹配时执行
    CASE { ... }        // case3 匹配时执行
    DEFAULT { ... }     // 无匹配时执行
}
```

Only the first matching CASE block executes; execution then exits the SWITCH.

#### EACH — Bounded Iteration（有限循环）

```go
{1, 3, 5, 7}           // 迭代目标集
EACH {
    $Value PUSH         // 入栈当前条目值
    // 循环变量通过 $Value, $Index/$Key, $Slice/$Dict, $Size 访问
}
```

There is **no unbounded loop** in the script system. `EACH` iterates over a finite collection (slice or dict). The loop body supports `BREAK` and `CONTINUE`.

### 4.6 Pattern Matching（模式匹配）

The `MODEL{}` instruction creates a pattern matching context that verifies whether a target script conforms to a specific structure. This is critical for cross-chain exchange scenarios where parties must verify each other's payment scripts.

```go
// 验证目标脚本是否为标准支付脚本
CODE{<target_script>}
MODEL {
    SYS_CHKPASS                     // 严格匹配
    SYS_TIME{Stamp} {?} #[32] GT   // 时间戳任意，提取值
    IF {
        MULSIG[0] PASS              // 严格匹配
        EXIT                        // 严格匹配
    }
    MULSIG[1] PASS                  // 严格匹配
    FN_HASH256                      // 严格匹配
    DATA[32]{?} #[32]               // 数据长度32字节，内容任意，提取值
    EQUAL PASS                      // 严格匹配
}
// Returns: ([timestamp, hashResult], Bool)
```

Pattern instructions support:
- **Exact matching**: Ordinary instructions in `MODEL{}` must match exactly.
- **Wildcards**: `_` (single instruction), `_[n]` (n instructions), `...` (zero or more instructions).
- **Optional matching**: `?{}` sequences that may or may not be present.
- **Type matching**: `!Bool`, `!Int`, `!Bytes`, etc.
- **Value extraction**: `#(bits)` extracts specific parts of matched instructions.
- **Range constraints**: `!{min, max}` for integer/float range matching.
- **Regex matching**: `RE{/.../}` for text/byte sequence pattern matching within MODEL.

### 4.7 External Interaction（外部交互）

Scripts interact with the outside world through two independent buffer queues:

```go
// 导出（非阻塞）
@POPS[3] OUTPUT     // 弹出栈顶3项 → 导出缓存区
BUFDUMP[tag]        // 触发外部监听器，清空导出缓存区

// 导入（阻塞）
INPUT[3]            // 从导入缓存区取3项 → 入栈
                    // 缓存区无数据时：失败但正常退出
```

**Export** is non-blocking: external listeners register handlers, export triggers event dispatch. Used for off-chain business logic.

**Import** is blocking: if the buffer is empty or has insufficient data, execution fails gracefully (pass-state preserved). For public validation nodes, `INPUT` acts as an implicit `END`.


## 5. Locking and Unlocking Flow（锁定与解锁执行流程）

### 5.1 Script Execution Pipeline（脚本执行管道）

When a transaction input references a previous output, the validation process is:

```
┌─────────────────────────────────────────────────────────┐
│ 1. Load unlock data into environment                    │
│    (sigType, authFlag, signatures, pubKeys, pubHashes)  │
├─────────────────────────────────────────────────────────┤
│ 2. Execute unlock script                                │
│    - Restricted to opcodes [0-49]                       │
│    - Primarily pushes values onto the data stack        │
├─────────────────────────────────────────────────────────┤
│ 3. Execute lock script                                  │
│    - Full instruction set available                     │
│    - Consumes values from the stack                     │
│    - Must achieve PASS state                            │
├─────────────────────────────────────────────────────────┤
│ 4. Check pass-state                                     │
│    - PASS: validation succeeds, UTXO can be spent       │
│    - FAIL: validation fails, transaction rejected       │
└─────────────────────────────────────────────────────────┘
```

### 5.2 Unlock Script Restrictions（解锁脚本限制）

Unlock scripts are restricted to opcodes `[0–49]` only:
- Value instructions (push data onto stack)
- Capture instructions (argument space manipulation)
- Stack operations (reordering)
- Collection operations (basic data structuring)
- Interaction instructions (import/export)

This prevents an unlock script from containing logic like `TRUE PASS EXIT` which would trivially bypass any lock. In practice, unlock scripts are primarily "data" — they provide the values that the lock script will verify.

### 5.3 Standard Payment Example（标准支付示例）

**Single-signature coin payment:**

```go
// 解锁数据 → 载入环境
// {1}          签名方法（单签）
// <flag>       授权标记
// <sig>        签名数据
// <pubKey>     公钥

// 锁定脚本
SYS_CHKPASS     // 系统内置验证：
                // 从环境取实参 (1, flag, sig, pubKey, receiver)
                // 验证签名，成功则 PASS
```

**Hash-barrier payment (e.g., for cross-chain exchange):**

```go
// 解锁脚本
<hashSource>            // 哈希原像入栈

// 锁定脚本
SYS_CHKPASS             // 签名验证
TOP                     // 复制栈顶（哈希原像）
FN_HASH256              // 计算哈希
DATA{<expected_hash>}   // 预置的哈希目标
EQUAL PASS              // 哈希屏障验证
END                     // 公共验证结束
@POP OUTPUT BUFDUMP     // 私有逻辑：导出哈希原像
```


## 6. Basic Turing Completeness（基本图灵完备性）

### 6.1 Capabilities（能力）

The script system achieves "basic Turing completeness" through the following mechanisms:

| Capability | Implementation |
|------------|---------------|
| **Sequential execution** | Linear instruction processing |
| **Conditional branching** | `IF{}`, `ELSE{}`, `SWITCH/CASE{}` |
| **Bounded iteration** | `EACH{}` over finite collections, `MAP{}`, `FILTER{}` |
| **Arithmetic** | Full arithmetic ops, expression syntax `()`, bit operations |
| **Data types** | Bool, Byte, Rune, Int, BigInt, Float, String, Bytes, RegExp, Time, Script, Dict |
| **Memory** | Data stack, argument space, local scopes, global variables |
| **Subroutines** | `GOTO` (independent), `EMBED` (merged), `EVAL` (isolated) |
| **Pattern matching** | `MODEL{}` for structural verification of scripts |
| **External I/O** | `INPUT`/`OUTPUT`/`BUFDUMP` for off-chain interaction |

### 6.2 Bounded by Design（有界设计）

The system is deliberately bounded to ensure predictable resource consumption:

- **No infinite loops**: Only `EACH` (iterating finite collections) and bounded `MAP`/`FILTER` exist.
- **No recursion**: GOTO depth is limited to 3, EMBED depth to 0. No instruction allows calling back to the same script.
- **No self-modification**: Scripts are read-only during execution.
- **Fixed stack capacity**: Maximum 256 entries prevents unbounded memory growth.
- **No dynamic code generation**: `CODE{}` creates inert data; only `EVAL` can execute it, in a fully isolated environment.

This makes the system practically Turing-complete (it can express any computation within its bounds) while guaranteeing termination and bounded resource usage — a deliberate trade-off for a blockchain execution environment.


## 7. Security Constraints（安全约束）

### 7.1 Runtime Limits（运行时限制）

| Parameter | Limit | Rationale |
|-----------|-------|-----------|
| Stack height | < 256 | Most data is consumed immediately; deep stacks indicate abuse |
| Stack item size | < 1 KB | Prevents oversized data entries |
| Lock script length | < 1 KB | Constrains lock logic complexity |
| Unlock script length | < 4 KB | Allows sufficient unlock data (Excluding standard signature data) |
| Transaction size | < 400 KB | Excluding unlock portion |
| Output count per tx | < 1024 | Single-byte 7-bit expression (128×8) |
| EMBED invocations | ≤ 4 | Runtime count, including sub-script embeds |
| EMBED depth | = 0 | Embedded scripts cannot further embed or GOTO |
| GOTO invocations | ≤ 2 | At main script level, runtime count |
| GOTO depth | ≤ 3 | Runtime count; design reference: manager + auditor + third-party |
| Unlock script opcodes | `[0–49]` only | Prevents bypass attacks |

### 7.2 Block Size Limits（区块容量限制）

Block size grows progressively to allow the network to scale:

| Period | Block Size Limit |
|--------|-----------------|
| Months 1–3 (21,915 blocks) | Fixed 1 MB |
| Months 4–36 | +1 MB per month (up to 34 MB) |
| Year 4+ (87,661 blocks/year) | +2 MB per year |

Block size includes unlock portions (excluding standard signature data).

### 7.3 Script Immutability（脚本不可变性）

- Scripts are **read-only** during execution. Instructions that perform mutations (e.g., collection modifications) operate on copies.
- `EVAL` provides isolated execution — the inner script's pass-state does not affect the caller.
- `SOURCE` returns byte-sequence copies of the script, not live references.

### 7.4 Extension Security（扩展安全性）

- `EX_PRIV` (private extensions) are ignored by public validation nodes — they exist only for private application logic.
- `EGO{}` and `SHELL{}` (embedded Go/Shell code) are only effective in attestation identification scripts; they are ignored by validation nodes in coin/voucher contexts.
- No conversion path from `Bytes` to `Script` type — preventing arbitrary code injection.


## 8. Type System（类型系统）

### 8.1 Supported Types（支持的类型）

```go
// 基础类型
type Nil    = nil           // 空值
type Bool   = bool          // 布尔值
type Byte   = uint8         // 单字节
type Rune   = rune          // Unicode 码点 (int32)
type Int    = int64         // 64位整数
type BigInt = *big.Int      // 任意精度整数
type Float  = float64       // 64位浮点数
type String = string        // UTF-8 字符串
type Bytes  = []byte        // 字节序列
type RegExp = *regexp.Regexp // 正则表达式
type Time   = time.Time     // 时间对象
type Script = []byte        // 指令序列（特殊类型标记）

// 复合类型
type Slice  = []any         // 通用切片
type Dict   = map[string]any // 字典
```

### 8.2 Type Promotion（类型提升）

When creating value sets `{...}`, types are automatically promoted along these paths:

```
Byte → Rune → Int → BigInt
Byte → Rune → Int → Float
```

Float and String are terminal types — they cannot be further promoted.

### 8.3 Conversion Instructions（转换指令）

Explicit type conversions are provided via dedicated instructions: `BOOL`, `BYTE`, `RUNE`, `INT`, `BIGINT`, `FLOAT`, `STRING`, `BYTES`, `RUNES`, `TIME`, `REGEXP`, `DICT`, `ANYS`.

**Security note**: Conversion from `Bytes` to `Script` is deliberately NOT supported to prevent code injection attacks.


## 9. Cross-Script References（跨脚本引用）

The script system supports three mechanisms for referencing external scripts:

### 9.1 SCRIPT — Value Reference（值引用）

```go
18  SCRIPT(~,64,~)  // 附参：年度, 交易ID, 输出序位
```

Loads the target transaction's output script as a `Script` value on the stack. The script is **not executed** — it is data that can be hashed, pattern-matched, or used with `EVAL`.

### 9.2 GOTO — Independent Execution（独立执行）

```go
52  GOTO(~,64,~)    // 独立跳转到外部脚本
```

Creates a new script domain and executes the target script. See Section 4.2 for details.

### 9.3 EMBED — Merged Execution（合并执行）

```go
53  EMBED(~,64,~)   // 嵌入外部脚本
```

Injects the target script into the current execution context. The embedded script shares the caller's data stack, argument space, and global variables. This is a **merge** operation — it is as if the embedded instructions were written inline.

**Constraint**: Embedded scripts cannot contain further `EMBED` or `GOTO` instructions (depth = 0).


## 10. Notation Conventions（书写约定）

For human-readable script representation:

| Symbol | Meaning |
|--------|---------|
| `{}`   | Associated data (code blocks, values) |
| `[]`   | Auxiliary parameters (optional when default) |
| `()`   | In documentation: auxiliary parameter byte length |
| `<>`   | Named data placeholder (e.g., `<pubKey>`, `<sig>`) |

**Display rules** for decompiled bytecode:
- Sub-blocks are indented.
- Long values (`DATA{}`, large integers, regex) appear on their own line.
- Result instructions (`PASS`, `RETURN`, `EXIT`) appear at line end.
- Capture prefixes (`@`, `~`, `$`) are adjacent to their target instruction.

### Source format example:

```go
SYS_CHKPASS
SYS_TIME{Stamp} {<expireTime>} GT
IF {
    MULSIG[0] PASS
    EXIT
}
MULSIG[1] PASS
FN_HASH256
DATA{<hashResult>}
EQUAL PASS
END

@POP OUTPUT BUFDUMP
```


## 11. Application Scenarios（应用场景）

The script system supports diverse use cases through composition of its primitives:

| Scenario | Key Mechanisms |
|----------|---------------|
| **Standard payment** | `SYS_CHKPASS` (single/multi-sig) |
| **Hash-barrier payment** | `FN_HASH256` + `DATA{}` + `EQUAL PASS` |
| **Time-locked redemption** | `SYS_TIME{Stamp}` + `IF{}` + `MULSIG` |
| **Cross-chain exchange** | Hash barriers + time locks + `MODEL{}` pattern verification + `OUTPUT`/`BUFDUMP` |
| **Escrow with expiry** | Multi-sig + time condition + hash barrier |
| **Script verification** | `MODEL{}` pattern matching for structural validation |
| **Off-chain coordination** | `OUTPUT`/`BUFDUMP` for event-driven middleware |
| **Voucher transfer** | `SYS_CHKPASS` with credit-specific validation logic |
| **Attestation identification** | `EGO{}`/`SHELL{}` for programmatic recognition |


## 12. Summary（总结）

The Evidcoin stack-based script system balances expressiveness with security through:

1. **Decoupled operand ordering** via the argument space mechanism, overcoming the rigidity of traditional stack languages.
2. **Comprehensive control flow** (IF/ELSE, SWITCH/CASE, EACH) providing basic Turing completeness within bounded resource limits.
3. **Four-segment extensible architecture** allowing the instruction set to grow from 170+ base instructions to theoretically unlimited extensions.
4. **Pattern matching** (`MODEL{}`) enabling trustless cross-script structural verification — a unique capability for cross-chain and automated workflows.
5. **Strict resource bounds** ensuring deterministic execution and preventing denial-of-service attacks.
6. **Clean separation** between unlock data (restricted opcodes [0–49]) and lock logic (full instruction set), maintaining security invariants.
7. **External interaction** through buffered I/O, bridging on-chain verification with off-chain business processes.
