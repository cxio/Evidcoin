# Team-Based Verification（组队校验）

> **Design Proposal** — This document describes the team-based transaction verification
> architecture of Evidcoin. It covers the verification team structure, role assignments,
> redundancy and review mechanisms, inter-team coordination, minting integration, UTXO
> fingerprinting, block publication, and security safeguards.


## 1. Overview（概述）

Traditional blockchains operate on a "single-node" model: every full node independently
verifies every transaction. As transaction volume grows, this places increasing hardware
demands on participants and limits the system's throughput ceiling.

Evidcoin replaces this model with **Team-Based Verification** — a cooperative architecture
where a group of nodes (a *verification team*) collectively validates an entire block's
transactions. Transactions are naturally independent units, making parallel distribution
across team members both logical and efficient.

Core design principles:

| Principle | Description |
|-----------|-------------|
| **Division over redundancy** | Full decentralized redundancy is unnecessary; division of responsibility suffices for security. |
| **Micro-centralized teams** | Each team operates with internal role hierarchy, but teams relate to each other as free P2P peers. |
| **Open membership** | Any node may freely join any team; capable nodes may participate in multiple teams simultaneously. |
| **Low barrier** | Creating a verification team requires only moderately capable hardware for the management layer; there are no artificial restrictions on entry. |


## 2. Team Structure and Roles（团队结构与角色分配）

A verification team consists of three functional roles plus a shared UTXO cache service.

```
┌─────────────────────────────────────────────────┐
│               Verification Team                 │
│                                                 │
│  ┌───────────────────────────────────────────┐  │
│  │         Management Layer（管理层）          │  │
│  │  ┌─────────────┐  ┌──────────────────┐    │  │
│  │  │ Broadcaster │  │    Dispatcher     │    │  │
│  │  │  （广播者）   │  │    （调度者）      │    │  │
│  │  └─────────────┘  └──────────────────┘    │  │
│  └───────────┬───────────────┬───────────────┘  │
│              │               │                  │
│     ┌────────┴──┐    ┌──────┴───────┐           │
│     │  Guards   │    │  Verifiers   │           │
│     │ （守卫者）  │    │  （校验员）   │           │
│     └───────────┘    └──────────────┘           │
│                                                 │
│     ┌───────────────────────────────────┐       │
│     │      UTXO Cache（UTXO 缓存器）     │       │
│     └───────────────────────────────────┘       │
└─────────────────────────────────────────────────┘
```


### 2.1 Management Layer（管理层）

The management layer contains two sub-roles: **Broadcaster** and **Dispatcher**.

#### 2.1.1 Broadcaster（广播者）

Responsibilities:
- Receives minting applications from eligible minters and orchestrates the minting workflow
  (Coinbase creation, CheckRoot delivery, signature collection, block header assembly).
- Packages and publishes the final block to the network.
- If another team mints the block, receives their published block, verifies it, fills in any
  locally missing transactions, and relays it onward.
- Directly verifies a small number of differential transactions (those present in the
  received block but absent from the local validated set) for efficiency and safety.

#### 2.1.2 Dispatcher（调度者）

Responsibilities:
- Receives transactions that passed leader verification from Guards and stores them in the
  pending verification pool.
- Assigns transactions to Verifiers with controlled redundancy (at least 2 Verifiers per
  transaction).
- Evaluates verification results and triggers extended review when results are inconsistent.
- Records each member's work performance for reward distribution.
- Synchronizes the set of validated transactions to the Broadcaster in real-time so the
  Broadcaster can package or verify blocks promptly.

#### 2.1.3 Management Layer Connections（管理层连接关系）

| Direction | Peers |
|-----------|-------|
| **Intra-team** | Guards (receive transactions), Verifiers (assign tasks and collect results) |
| **Inter-team** | Broadcasters of other verification teams |


### 2.2 Guards（守卫者）

Guards are the gatekeepers of the team — the sole entry point for external transactions.

Responsibilities:
- Receive transactions from other teams' Guards and Verifiers.
- Perform **Leader Verification** (see §3) on each incoming transaction.
- Submit transactions that pass leader verification to the Dispatcher.
- Forward received transactions to Guards of other teams for rapid network-wide broadcast.
- Maintain a **blacklist** of leader inputs from transactions that passed leader verification
  but ultimately failed full verification.

The Management Layer continuously synchronizes the IDs of already-submitted transactions to
Guards, preventing redundant verification and submission. This does not affect the Guard's
duty to relay transactions to other teams' Guards.

#### Guard Connections（守卫者连接关系）

| Direction | Peers |
|-----------|-------|
| **Intra-team** | Management Layer (submit verified transactions) |
| **Inter-team** | Receives from: other teams' Guards and Verifiers. Sends to: other teams' Guards. |


### 2.3 Verifiers（校验员）

Verifiers perform full transaction validation.

Responsibilities:
- Request verification tasks from the Dispatcher.
- Execute complete validation (script execution, input verification, amount checks, etc.)
  and report results — whether pass or fail — back to the Dispatcher.
- Send successfully verified transactions to Guards of other teams, accelerating network
  propagation.

Implementation notes:
- Verifiers do not know whether an assigned transaction is a routine verification or a review
  re-check. This information asymmetry deters collusion and malicious behavior.
- If a transaction requires excessive computation, a Verifier may decline and return an
  *overloaded* message. If the Dispatcher receives multiple such responses for the same
  transaction, it may deprioritize (cold-treat) that transaction.

#### Verifier Connections（校验员连接关系）

| Direction | Peers |
|-----------|-------|
| **Intra-team** | Management Layer (request tasks, submit results) |
| **Inter-team** | Sends to: other teams' Guards (provide verified transactions) |


### 2.4 UTXO Cache（UTXO 缓存器）

The UTXO Cache is a shared intra-team service that maintains the current UTXO set and
provides lookup capability for Guards and Verifiers.

```go
// UTXOCache 提供组内 UTXO 集的缓存查询服务。
type UTXOCache interface {
    // Lookup 查询指定输出点是否未花费，并返回其信息。
    Lookup(outpoint Outpoint) (*UTXOEntry, error)

    // Update 标记一笔交易的输入为已花费，输出为新增。
    // 如果检测到双花，返回 ErrDoubleSpend。
    Update(tx *Transaction) error

    // ScriptCache 获取外部脚本缓存（GOTO/EMBED/SCRIPT 引用）。
    ScriptCache() ScriptStore
}
```

Key behaviors:
- When the Management Layer confirms a transaction as valid, it pushes the transaction to
  the UTXO Cache for tentative application.
- The UTXO Cache independently checks for **double-spending** and immediately reports
  violations to the Management Layer, which then issues a network-wide alert.
- The UTXO Cache may also integrate a cache for externally referenced scripts (`GOTO`,
  `EMBED`, `SCRIPT` instructions), reducing repeated fetches from Blockqs/Depots.


## 3. Leader Verification（首领校验）

Leader Verification is a lightweight pre-check performed by Guards on incoming transactions.
Only the **first input** (the "leader input") is validated; if it passes, the transaction
is forwarded for full verification.

### 3.1 Purpose（目的）

Leader Verification enables rapid transaction propagation across the network without the
cost of full validation. By verifying only one input, Guards can quickly determine whether
a transaction is likely legitimate and relay it in near real-time.

### 3.2 Constraints（约束条件）

To limit abuse (e.g., flooding attacks with transactions whose leader input is valid but
subsequent inputs are invalid):

1. **The leader input must be a Coin type** (币金) and must carry the highest coin-age
   (币权) among all coin inputs in the transaction.
2. **Blacklisting**: If a transaction passes leader verification but ultimately fails full
   verification, the leader input's reference is added to a temporary blacklist.
3. **Freeze duration**: Blacklisted leader inputs are frozen for **24 hours**, during which
   any new transaction referencing the same input as leader is rejected at the Guard level.

This makes flooding attacks expensive: the attacker must burn valid high-value coin-age
UTXOs, each of which becomes frozen for 24 hours upon detection.


## 4. Security Mechanisms（安全保障机制）

### 4.1 Redundant Verification（冗余校验）

Every transaction is assigned to multiple Verifiers (redundancy ≥ 2, configurable by the
team). Results are combined:

| Result | Outcome |
|--------|---------|
| All Verifiers report valid | Transaction accepted as valid |
| At least one reports invalid | Transaction enters Extended Review |

### 4.2 Extended Review（扩展复核）

When verification results are inconsistent, the Dispatcher escalates to higher-performing
Verifiers (selected by past performance metrics). The review is also redundant.

**Level 1 Review（一级复核）:**

| Result | Outcome |
|--------|---------|
| Zero error reports | Transaction accepted as valid |
| More than half report invalid | Transaction rejected as invalid |
| Less than half report invalid | Escalate to Level 2 |

**Level 2 Review（二级复核）:**

| Result | Outcome |
|--------|---------|
| Any error report | Transaction rejected as invalid |
| All report valid | Transaction accepted as valid |

A transaction rejected through extended review is not permanently discarded. If another
verification team validates it and includes it in a published block, the receiving team
will re-verify it during block synchronization.

### 4.3 Inter-Team Feedback（组间反馈）

Verifiers directly send validated transactions to Guards of other teams. If a receiving
Guard's team later determines the transaction is invalid, the Guard notifies the originating
Verifier, who may then re-verify. This cross-team feedback loop significantly strengthens
overall verification reliability.

The Management Layer maintains records of which Guard delivered each transaction, enabling
traceback to the originating Verifier from another team.


## 5. Transaction Inclusion Priority（交易收录优先级）

The Management Layer follows these priority rules when assembling transactions into a block:

| Priority | Criterion |
|----------|-----------|
| **Highest** | Earlier input timestamp (the oldest unspent input determines the transaction's age) |
| **Secondary** | Higher coin-age destruction (Stakes) or higher transaction fee |


## 6. Minting Integration（铸造集成）

### 6.1 Minter Identity（铸造者身份）

Only members of the Best Pool (择优池) may sign blocks. Minting competition is open to all
roles — Management Layer operators, Guards, Verifiers, and even spectators (围观者) who do
not participate in verification work.

The Management Layer does not know which nodes hold minting eligibility (minting pre-selection
is independent of transaction verification). A minter may simultaneously participate in
multiple teams and could theoretically sign multiple blocks.

### 6.2 Lowest-Revenue Principle（低收益原则）

To prevent a minter from signing multiple competing blocks for profit:

> **Rule**: When the same minter signs multiple blocks at the same height, only the block
> with the **lowest revenue** is considered valid.

This eliminates the incentive for multi-signing and also prevents teams from re-packaging
blocks with newly arrived high-fee transactions, which would delay timely block production.

### 6.3 Information Separation（信息分离）

The minting process deliberately separates information between the minter and the Management
Layer, creating mutual checks:

- The **minter** constructs the Coinbase transaction but does not know the full block's
  `CheckRoot` (the combined hash of the transaction hash tree root and UTXO fingerprint).
- The **Management Layer** knows the `CheckRoot` but cannot forge the minter's signature.

This separation prevents either party from unilaterally cheating.

### 6.4 Minting Workflow（铸造流程）

```
Minter                         Management Layer
  │                                   │
  │  1. Submit Best Pool proof        │
  ├──────────────────────────────────►│
  │                                   │
  │  2. Return: fee total, reward     │
  │     addresses, minting amount,    │
  │     service reward addresses      │
  │◄──────────────────────────────────┤
  │                                   │
  │  3. Construct & submit Coinbase   │
  ├──────────────────────────────────►│
  │                                   │  Verify Coinbase,
  │                                   │  package block,
  │                                   │  compute hash tree
  │  4. Return: Coinbase Merkle path, │
  │     TreeRoot, UTXO fingerprint    │
  │◄──────────────────────────────────┤
  │                                   │
  │  Verify Coinbase is included      │
  │  (via Merkle path)                │
  │                                   │
  │  5. Sign CheckRoot, submit        │
  ├──────────────────────────────────►│
  │                                   │  Verify signature,
  │                                   │  assemble block header,
  │                                   │  publish block
  │  6. Block published               │
  │◄──────────────────────────────────┤
```

Notes:
- The block header is created by the Management Layer, giving it autonomy over version
  control and structural decisions.
- The minter verifies that its Coinbase transaction is included in the hash tree before
  signing, using the returned Merkle path.
- If the minter specifies its own preferred public service reward addresses and the
  Management Layer rejects them, the minter will not receive the signing data. The minter
  may then try other teams.

### 6.5 Spectator Participation（围观者参与）

Minting competition is independent of verification work. To maximize the pool of minting
candidates (enhancing security through broader competition), verification teams allow
non-verifying nodes — **spectators** — to join as minting candidates.

This is effectively unavoidable: if a spectator wins the Best Pool competition, it must be
able to enter a team to execute the minting workflow.

The Management Layer provides spectator minters with optional information:
- Suggested public service reward addresses
- Reward slot markers for the Coinbase transaction

These are advisory; the minter retains final discretion.

### 6.6 Anti-Selfish-Minting: Stakes Threshold（防自私铸造：币权阈值）

A minter could theoretically produce an empty block (containing only the Coinbase
transaction) without needing team assistance, since it only needs the previous block ID
and the current UTXO fingerprint.

To deter this:

> **Rule**: If a candidate block's total Stakes destruction exceeds the primary block's
> Stakes by a factor of **3×**, the candidate block wins.

This ensures that a selfishly minted primary block with near-zero Stakes will be displaced
by any candidate block that verifies even approximately 1/3 of the available transactions.
For a lone spectator or individual Verifier, achieving 1/3 of the transaction volume is
impractical.

| Term | Definition |
|------|------------|
| **Primary block** | The block minted by the Best Pool's top-ranked candidate |
| **Candidate block** | A block minted by the next-ranked candidate (redundancy safety) |


## 7. Block Publication（区块发布）

Block publication is optimized for network efficiency and proceeds in three stages:

### 7.1 Stage 1: Block Proof Broadcast（广播区块证明）

Minimal proof data is broadcast first:
- Coinbase transaction
- Coinbase Merkle verification path (hash sequence linking Coinbase to TreeRoot)
- Minter's signature
- Block header

This allows receiving teams to immediately verify the block's authenticity without
downloading all transactions.

### 7.2 Stage 2: Block Summary（发布区块概要）

The full transaction ID list is published, with optimization:
- Each transaction ID is **truncated to the first 16 bytes** and transmitted in sequence.
- For a block with 64K transactions: `64K × 16 = 1 MB` of data.
- Receivers compare truncated IDs against their local validated transaction set.
- Missing or ambiguous entries (hash prefix collision, though extremely rare) trigger
  requests for full IDs.

### 7.3 Stage 3: Transaction Synchronization（同步交易数据）

Full transaction data for all block entries is synchronized. Since most teams will already
have validated the majority of transactions, only a small number of missing transactions
need to be fetched. Receivers then:
1. Reconstruct the transaction hash tree.
2. Verify the computed tree root against the block header's `CheckRoot`.
3. Accept or reject the block.


## 8. UTXO Fingerprint（UTXO 指纹）

### 8.1 Structure（结构）

The UTXO fingerprint is a 4-level hierarchical hash over the entire UTXO set, designed to
minimize recomputation when individual outputs change:

```
Level 1: Year         ─── Year of the transaction timestamp (UTC)
Level 2: Transaction  ─── Transaction ID within that year
Level 3: Output       ─── Output index within the transaction
Level 4: Hash Leaf    ─── SHA-512 hash of the output data
```

```
┌─────────────────────────────────────┐
│         UTXO Fingerprint            │
│       (top-level hash)              │
└──────────┬──────────────────────────┘
           │
    ┌──────┴──────┬──────────┬─────┐
  Year₁        Year₂      Year₃  ...
    │
  ┌─┴───┬───────┬─────┐
 Tx_A  Tx_B   Tx_C   ...
  │
 ┌┴──┬────┐
Out₀ Out₁ ...
  │
 Hash(output data)
```

### 8.2 Computation Efficiency（计算效率）

When a transaction spends an output:
1. Only the affected **Output** hash is removed.
2. The parent **Transaction** hash is recomputed from remaining outputs.
3. The parent **Year** hash is recomputed.
4. The top-level **Fingerprint** is recomputed.

Most years' hashes remain unchanged, making incremental updates efficient.

### 8.3 Dual-Chain Protection（双链保护）

The UTXO fingerprint, combined with the block ID chain, forms a **dual-chain protection**
mechanism for blockchain history:

- **Block ID chain**: Each block header contains `PrevBlock`, linking blocks sequentially.
- **UTXO fingerprint chain**: Each block's `CheckRoot` incorporates the UTXO fingerprint,
  which summarizes all historical transaction outcomes.

An attacker would need to forge both chains simultaneously to alter history — the block
headers and the cumulative UTXO state — making historical reconstruction practically
infeasible.

### 8.4 Chain Constraint（链式约束）

Key definitions:
- **Current block**: The block currently being validated and assembled.
- **Current UTXO set**: The UTXO set that the current block's transactions are validated
  against. It does **not** yet reflect the current block's own spending.

The current block's UTXO fingerprint is computed from the *current UTXO set* (i.e., the
result of the previous block's transactions). This provides ample computation time and
creates a recursive chain constraint:

```
UTXO Set(N) ──fingerprint──► Block(N).CheckRoot
    │
    │  Apply Block(N) transactions
    ▼
UTXO Set(N+1) ──fingerprint──► Block(N+1).CheckRoot
```

**Reverse verification**: Given the current UTXO set and a block's transactions, one can
reverse-derive the previous block's UTXO set and verify its fingerprint against the stored
block header. This can be repeated iteratively to validate the chain to any historical depth.

### 8.5 New Node Bootstrap（新节点引导）

Thanks to the UTXO fingerprint, a newly joining node needs only:
1. The block header chain (or year-block skeleton for older history)
2. The most recent ~9 blocks with full data
3. The current UTXO set

This minimal data set allows the node to verify the current chain state with high confidence,
dramatically lowering the barrier to entry.


## 9. Optimal Team Size（最优规模）

Larger teams are not necessarily better. Estimation for a 6-minute block interval with up
to 64K transactions per block:

- Throughput: ~182 transactions/second
- Estimated sufficient team size: **50–60 nodes**

Verifiers freely claim tasks — capable nodes process more, weaker nodes process less. This
self-adaptive workload distribution naturally balances the team.


## 10. Hash Verification Tree with Ordered Leaves（含序哈希校验树）

The hash verification tree used for block transactions supports **ordered leaf nodes**:
each leaf (transaction ID) carries a 3-byte sequence prefix. This enables:

| Capability | Description |
|------------|-------------|
| **Random sampling** | Spot-check arbitrary positions in the tree without downloading all transactions |
| **Positional extraction** | Locate and verify a specific transaction by position within the block |
| **Sync optimization** | Identify missing transaction positions (not just IDs) during inter-node synchronization |

This structure is also used for attachment shard hash trees, enabling partial verification
of large file attachments.


## 11. Known Limitations（已知不足）

| Limitation | Description |
|------------|-------------|
| **Trust in Management Layer** | The minter must send revenue to addresses specified by the Management Layer, requiring a degree of trust. |
| **Self-minting Management** | If the Management Layer itself is the minter, there is no mechanism to prevent it from retaining all revenue. This can only be mitigated through sufficient market competition among teams. |
| **Evaluation subjectivity** | Public service reward evaluation is local and probabilistic, not globally verifiable (see Services proposal §4). |


## 12. Inter-Team Topology（组间拓扑）

```
  ┌──────────┐         ┌──────────┐         ┌──────────┐
  │  Team A  │         │  Team B  │         │  Team C  │
  │          │         │          │         │          │
  │ Broad.◄──┼────────►┼──►Broad. │◄───────►┼──►Broad. │
  │          │         │          │         │          │
  │ Guard ◄──┼────┐    │  Guard ◄─┼───┐     │  Guard   │
  │          │    │    │          │   │     │          │
  │ Verif.───┼────┼───►┼──►Guard  │   │     │          │
  │          │    │    │  Verif.──┼───┼────►┼──►Guard  │
  └──────────┘    │    └──────────┘   │     └──────────┘
                  │                   │
                  └───────────────────┘
```

- **Broadcaster ↔ Broadcaster**: Full mesh between teams for block exchange.
- **Verifier → Guard**: Cross-team delivery of validated transactions.
- **Guard ← Guard/Verifier**: Cross-team reception of incoming transactions.

Each team is a semi-open micro-center: internally hierarchical, externally P2P.
