# Transaction Design Proposal（交易设计提案）

> This proposal defines the transaction model for the Evidcoin blockchain, covering structure, hashing, UTXO fingerprinting, Coinbase transactions, storage, and size/fee constraints.


## 1. Overview（概述）

Transactions are the fundamental carriers of credit transfer in Evidcoin. Unlike Bitcoin where transaction history is purely storage, Evidcoin's transaction history must support downstream needs: script application identification, intermediary script references, and third-party development.

The design prioritizes:

- **Verifiability**: Hash trees for independent verification of inputs and outputs.
- **Retrievability**: Structured indexing by year and TxID for efficient lookup.
- **Signature separation**: Signatures do NOT participate in TxID computation, enabling flexible authorization models.
- **Compactness**: MaxTxSize = 8192 bytes with space-efficient input references.


## 2. Transaction Header（交易头）

The transaction header is a compact abstraction of the full transaction, analogous to how block headers abstract blocks.

```go
// TxHeader 交易头结构。
// 交易头的哈希即为交易 ID（TxID）。
type TxHeader struct {
    Version   int      // 版本号
    Timestamp int64    // 交易时间戳（Unix 纳秒）
    HashBody  Hash512  // 交易体哈希
}
```

### 2.1 TxID Computation（交易 ID 计算）

```
TxID = SHA-512( TxHeader )
```

Key rule: **Signatures are excluded from TxID computation.** The TxID is derived solely from the header, which contains `HashBody` — itself derived from inputs and outputs only. This separation prevents transaction malleability and allows signatures to be verified independently.

### 2.2 HashBody Computation（交易体哈希计算）

```
HashBody = SHA-512( InputHash || OutputHash )
```

Where `InputHash` and `OutputHash` are the respective hash tree roots of the input set and output set. The `||` operator denotes byte concatenation.


## 3. Transaction Body（交易体）

The body consists of two collections: **inputs** (credit sources) and **outputs** (credit destinations).

### 3.1 Inputs（输入项）

Each input references an unspent output (UTXO) from a confirmed transaction.

> **Rule**: Unconfirmed transaction outputs CANNOT be used as inputs. This ensures transaction independence for team-based verification.

#### 3.1.1 Input Structure（输入项结构）

An input consists of 3–4 fields:

| Field | Size | Description |
|-------|------|-------------|
| Year | varint | Year of the referenced transaction (coarse time constraint) |
| TxIDRef | 64 bytes (lead) / 20 bytes (rest) | Transaction ID reference |
| OutIndex | varint | Output index in the referenced transaction |
| TransferIndex | varint (optional) | For credential transfers: target output position in the current transaction |

```go
// LeadInput 首领输入，使用完整的交易 ID 引用。
type LeadInput struct {
    Year          int       // 交易所在年度
    TxID          Hash512   // 完整交易 ID（64 字节）
    OutIndex      int       // 输出序位
    TransferIndex int       // 凭信转出序位（可选）
}

// RestInput 非首领输入，使用截断的交易 ID 引用以节省空间。
type RestInput struct {
    Year          int       // 交易所在年度
    TxIDPart      [20]byte  // 交易 ID 前 20 字节
    OutIndex      int       // 输出序位
    TransferIndex int       // 凭信转出序位（可选）
}
```

**Design rationale**:

- The **lead input** uses a full 64-byte TxID for credential owner retrieval and robust verification.
- **Remaining inputs** use 20-byte truncated references for space efficiency. Since all inputs are resolved against the current UTXO set (which is verified by the UTXO fingerprint), the 20-byte prefix is sufficient — collisions are negligible in practice.

#### 3.1.2 Lead Input Constraints（首领输入约束）

For anti-flooding protection (see "Team-based Verification" design):

- The lead input MUST be a **coin** type with the **largest coin-age** among all coin inputs.
- If the transaction ultimately fails full verification, the lead input enters a **blacklist** with a 24-hour temporary freeze.

#### 3.1.3 Input Hash Tree（输入哈希树）

The input set is hashed into a two-layer tree with the lead input separated:

```
InputHash = SHA-512( LeadHash || RestHash )

LeadHash  = SHA-512( Year || TxID[64] || OutIndex )

RestHash  = SHA-512( RestInput_1 || RestInput_2 || ... || RestInput_N )
```

Separating the lead input enables fast positioning and verification of credential ownership by minters, without processing all inputs.

#### 3.1.4 Input Validation（输入验证）

Each input is validated via script execution:

```
UnlockScript + LockScript → Execute → Success = Valid
```

The unlock script provides proof of ownership; the lock script (from the referenced output) defines the spending conditions.


### 3.2 Outputs（输出项）

Each output defines a credit destination — a recipient receiving coins, credentials, or attestations.

#### 3.2.1 Output Structure（输出项结构）

```go
// Output 交易输出项。
type Output struct {
    Serial     int        // 输出序位（从 0 开始）
    Config     byte       // 配置字节（类型 + 标记位）
    Amount     int64      // 币金数量（按最小单位 chx）
    Address    [48]byte   // 接收地址（SHA-384 公钥哈希）
    LockScript []byte     // 锁定脚本（最大 1024 字节）
    // 以下字段按信元类型选择性存在
    Memo       []byte     // 附言（币金，最大 255 字节）
    Creator    []byte     // 创建者（凭信/存证）
    Title      []byte     // 标题（凭信/存证，最大 255 字节）
    Desc       []byte     // 描述（凭信/存证）
    AttachID   []byte     // 附件 ID（可选）
    CredConfig uint16     // 凭信配置（2 字节）
}
```

#### 3.2.2 Output Config Byte（输出配置字节）

The 1-byte config encodes type and flags:

```
Bit 7: Custom class    — When set, remaining 7 bits encode class ID length.
Bit 6: Has attachment  — Declares attachment presence (repurposed if Bit 7 set).
Bit 5: Burn flag       — Marks coin destruction or credential termination.
Bit 4: (Reserved)
Bits [3:0]: Type value:
    0 = Reserved
    1 = Coin         — Value transfer, can be UTXO input source.
    2 = Credential   — Credit certificate, transferable, can be UTXO input source.
    3 = Attestation  — Existence proof, NOT transferable, cannot be input source.
    4 = Intermediary — Receives cross-transaction script jumps (GOTO/EMBED).
```

#### 3.2.3 Address Format（地址格式）

Addresses are derived from public key hashes:

- **Hash algorithm**: SHA-384, producing a 48-byte public key hash.
- **Single-signature**: `Address = SHA-384( pubKey )`
- **Multi-signature**: `Address = SHA-384( <m/N> || sort(PKH_1 || PKH_2 || ... || PKH_N) )`
  - `m/N` prefix is 2 bytes (1 byte each), supporting up to 255-of-255 schemes.
  - Multi-sig and single-sig addresses are visually indistinguishable (privacy).

The `null` address represents a burn destination — outputs sent to `null` are excluded from the UTXO set.

**Address encoding** (for human-readable form):

1. Prepend an identifier prefix to the public key hash.
2. Hash the prefixed data, take the last 4 bytes as a **checksum**.
3. Append checksum to the public key hash (without prefix), encode as text (modified Base32).
4. Prepend the identifier prefix to produce the final address string.

#### 3.2.4 Output Hash Tree（输出哈希树）

Outputs form a binary Merkle-like hash tree:

```
OutputHash = SHA-512( BinaryTree( Output_0, Output_1, ..., Output_N ) )
```

Each output is individually hashed as a leaf node. The binary tree structure enables independent verification and positional lookup of any single output without processing the full set.

#### 3.2.5 Special Output Types（特殊输出类型）

**Burn outputs**: When the burn flag (Bit 5) is set, the output is removed from the UTXO set. The address may be `null`, and the lock script can be empty or contain a simple `NIL`.

**Intermediary scripts**: Type 4 outputs serve as cross-transaction jump targets. They cannot be UTXO input sources — they are referenced only via script instructions (`GOTO`, `EMBED`). Consecutive cross-transaction jumps are rate-limited for security.

**Custom classes**: Type with Bit 7 set. Contains private extension instructions for specialized clients. Up to 127 bytes of class ID for client identification. Cannot serve as UTXO input sources.


## 4. Signature Model（签名模型）

Signatures prove ownership of inputs but are **structurally separated** from the transaction body that determines TxID.

### 4.1 Single Signature（单签名）

Standard case: one private key signs the transaction. Sufficient for most individual transfers.

### 4.2 Multi-Signature（多重签名）

M-of-N scheme where M out of N key holders must sign.

**Unlock data for multi-sig verification**:

| Component | Description |
|-----------|-------------|
| Signature set | M signatures from the participating private keys |
| Public key set | M corresponding public keys |
| Complement set | N−M public key hashes of non-signing participants |

**Verification process**:

1. Compute `m/N` from the sizes of public key set and complement set.
2. Hash each public key in the public key set.
3. Merge hashed public keys with complement hashes, sort, prepend `m/N`, compute composite hash.
4. Compare with the output's address hash — match means valid identity.
5. Verify each signature in the signature set.

### 4.3 Signature Authorization Types（签名授权种类）

A 1-byte config controls what the signature covers:

```
Bit 7: SIGIN_ALL     — All inputs
Bit 6: SIGIN_SELF    — Current input only
Bit 5: SIGOUT_ALL    — All outputs (coin, credential, attestation)
Bit 4: SIGOUT_SELF   — Output at same index as current input
Bit 3: SIGOUTPUT     — Full output entry (receiver + content + script)
Bit 2: SIGSCRIPT     — Output's lock script only
Bit 1: SIGCONTENT    — Output's content only
Bit 0: SIGRECEIVER   — Output's receiver only
```

**Usage rules**:

- **Independent bits** (7, 6): Can be used alone. Example: `SIGIN_ALL` signs all inputs.
- **Primary bits** (5, 4): Must combine with auxiliary bits (3–0). Example: `SIGOUT_ALL | SIGRECEIVER`.
- **Auxiliary bits** (3–0): Must accompany a primary bit.

**Most common configuration**: `SIGIN_ALL | SIGOUT_ALL | SIGOUTPUT` — covers all inputs and all complete output entries.


## 5. Coinbase Transaction（铸币交易）

The Coinbase transaction is the first transaction in each block (index `[0]`). It has no inputs — it creates new coins from nothing.

### 5.1 Coinbase Structure（铸币交易结构）

```go
// CoinbaseTx 铸币交易特殊结构。
type CoinbaseTx struct {
    Header      TxHeader   // 标准交易头
    BlockHeight int        // 区块高度
    MeritProof  []byte     // 择优凭证（铸造者证明）
    TotalReward int64      // 收益总额
    FreeData    []byte     // 自由数据（最大 256 字节）
    Outputs     []Output   // 收益分配输出
}
```

### 5.2 Revenue Composition（收益构成）

```
TotalReward = BlockReward + TransactionFees + LotteryRetention
```

- **BlockReward**: New coins minted per block (decreasing schedule).
- **TransactionFees**: Only **50%** of total fees appear in Coinbase revenue — the other 50% is permanently burned. This creates deflationary pressure.
- **LotteryRetention**: Retained from the lottery reward pool.

### 5.3 Revenue Distribution（收益分成）

Coinbase outputs distribute rewards to multiple parties:

| Recipient | Description |
|-----------|-------------|
| Minter (check team) | Block minting reward share |
| Credential minter | Reward for credential transaction providers |
| Blockqs | Block query service nodes |
| Depots | Data depot service nodes |
| STUN services | NAT traversal service providers |

### 5.4 Minting Process（铸造流程）

1. **Application**: Eligible minter (merit pool member) submits merit proof to the management layer.
2. **Information exchange**: Management layer provides fee totals, team reward addresses, service addresses, minting amount.
3. **Construction**: Minter constructs Coinbase transaction following the distribution rules and submits it.
4. **Verification**: Management layer verifies the Coinbase, packages the block, and returns the hash tree verification path (including TreeRoot and UTXO fingerprint).
5. **Signing**: Minter verifies their Coinbase is included (via hash path), signs CheckRoot, and submits the signature.
6. **Publication**: Management layer constructs the block header and broadcasts.

### 5.5 Low-Revenue Principle（低收益原则）

If the same minter signs multiple blocks at the same height, **only the block with the lowest revenue is valid**. This prevents multi-signing and incentivizes timely block production.


## 6. UTXO Model and Fingerprint（UTXO 模型与指纹）

### 6.1 UTXO Set Definition（UTXO 集定义）

The UTXO set comprises all unspent outputs from confirmed transactions. It is determined by the previous block.

**Exclusions from UTXO**:

- Unconfirmed transaction outputs (no chained unconfirmed spending).
- Outputs with the burn flag set.
- Attestation outputs (type 3, not transferable).
- Intermediary script outputs (type 4).
- Custom class outputs (Bit 7 set).
- Expired credentials (transfer count or time limit reached).

### 6.2 UTXO Fingerprint — 4-Level Hierarchical Hash（UTXO 指纹 — 4 级层次哈希）

The UTXO fingerprint is a wide-member hash verification tree with **4 hierarchical levels**, designed to minimize recomputation when outputs change.

```
Level 1 (Root):    UTXOFingerprint = SHA-512( Year_1 || Year_2 || ... || Year_N )
Level 2 (Year):    YearHash_y      = SHA-512( TxHash_1 || TxHash_2 || ... )
Level 3 (Tx):      TxHash_t        = SHA-512( OutHash_1 || OutHash_2 || ... )
Level 4 (Output):  OutHash_o       = SHA-512( UTXO output data )
```

```go
// UTXOFingerprint 4 级层次哈希结构。
//
// Level 1: 年度级 — 按交易时间戳的 UTC 年度分组
// Level 2: 交易级 — 同一年度内按交易 ID 分组
// Level 3: 输出级 — 同一交易内按输出序位分组
// Level 4: 哈希叶 — 单个 UTXO 输出数据的哈希
type UTXOFingerprint struct {
    Root      Hash512                // 指纹根哈希
    YearNodes map[int]*YearNode      // 年度 → 年度节点
}

type YearNode struct {
    Year    int                      // UTC 年度
    Hash    Hash512                  // 年度哈希
    TxNodes map[Hash512]*TxNode      // TxID → 交易节点
}

type TxNode struct {
    TxID    Hash512                  // 交易 ID
    Hash    Hash512                  // 交易级哈希
    Outputs map[int]Hash512          // 输出序位 → 输出哈希
}
```

**Design benefits**:

- **Incremental update**: When a UTXO is spent, only the affected branch (output → transaction → year → root) needs recomputation.
- **Year-based partitioning**: Top level groups by transaction timestamp year (UTC), providing natural sharding with acceptable granularity.
- **Dual-path history protection**: Together with block ID chaining, the UTXO fingerprint provides a second independent proof of blockchain history integrity.
- **Fast node bootstrap**: A new node can verify the current UTXO set via the fingerprint in the latest block header, without replaying the full history.

### 6.3 CheckRoot（校验根）

CheckRoot links the transaction hash tree and UTXO fingerprint into a single verifiable value stored in the block header:

```
CheckRoot = SHA-512( TxTreeRoot || UTXOFingerprint )
```

Where:
- `TxTreeRoot` is the Merkle-like binary hash tree root of all transaction IDs in the block (leaves are TxIDs with 3-byte sequence prefix).
- `UTXOFingerprint` is the root hash of the 4-level UTXO fingerprint structure.

The minter signs `CheckRoot`. The management layer constructs the block header containing `CheckRoot`. This creates **information separation**: the minter can verify their Coinbase inclusion via the hash path but cannot see (or manipulate) the full block composition.

### 6.4 UTXO Set Transition（UTXO 集转换）

For block at height `H`:

```
UTXO_current(H)  = The UTXO set for block H (before applying block H's transactions)
UTXO_result(H)   = UTXO_current(H) − spent_by(H) + new_outputs(H) + coinbase(H)
UTXO_current(H+1) = UTXO_result(H)
```

The UTXO fingerprint in block `H` is computed from `UTXO_current(H)` — before applying block H's transactions. This provides ample computation time and creates a chain-like constraint that can be reverse-verified.

**Reverse verification**: Given `UTXO_current(H+1)` and the transactions in block `H`, one can reconstruct `UTXO_current(H)` and verify it against block H's fingerprint. This can be iterated backward to any historical point.


## 7. Transaction Storage and Retrieval（交易存储与检索）

Full transaction storage is provided by external third-party public services, not by the core blockchain.

### 7.1 Storage Architecture（存储架构）

| Aspect | Service | Index | Purpose |
|--------|---------|-------|---------|
| Data | Blockqs | Year + TxID | Full transaction data for users |
| Verification | Blockqs | Year + BlockHeight | TxID lists within blocks, hash tree verification paths |
| Attachments | Depots | AttachID | Attachment data via P2P file sharing |

### 7.2 Query and Verification Flow（查询与验证流程）

Given a `TxID` and timestamp (or year):

1. **Locate**: Query Blockqs with year + TxID to retrieve full transaction data and metadata.
2. **Position**: Metadata includes the block height and position index within the block.
3. **Verify**: Obtain the hash tree verification path from Blockqs. Combine with the user's local block header chain to verify:
   - Recompute TxID from transaction data.
   - Verify TxID's inclusion in the block's transaction hash tree via the verification path.
   - Confirm the tree root matches `CheckRoot` in the block header.

The user's **local block header chain** is the trust anchor for all transaction verification.

### 7.3 Attachment Storage（附件存储）

Attachments are stored externally in Depots and transferred via P2P.

**Attachment ID structure** (variable length, < 256 bytes total):

```go
// AttachmentID 附件标识结构。
type AttachmentID struct {
    TotalLen      byte       // ID 总长
    MajorType     byte       // 附件大类
    MinorType     byte       // 附件小类
    FingerprintLv byte       // 指纹强度等级（0=16B, 1=20B, ... 12=64B）
    Fingerprint   []byte     // BLAKE3 哈希指纹（16–64 字节）
    ShardCount    uint16     // 分片数量（最大 65535）
    ShardTreeHash [48]byte   // 片组哈希树根（SHA-384）
    DataSize      int        // 附件大小（变长整数，单位：字节）
}
```

**Shard verification**: For partial data retrieval, each shard can be independently verified via its sequence-prefixed hash and the Merkle path to the shard tree root.


## 8. Transaction Size and Fee Constraints（交易大小与费用约束）

### 8.1 Size Limits（大小限制）

| Constant | Value | Description |
|----------|-------|-------------|
| MaxTxSize | 8192 bytes | Maximum single transaction size |
| MaxLockScript | 1024 bytes | Maximum lock script length |
| MaxUnlockScript | 4096 bytes | Maximum unlock script length |
| MaxMemo | 255 bytes | Maximum coin payment memo |
| MaxTitle | 255 bytes | Maximum credential/attestation title |
| MaxCredDesc | 1023 bytes | Maximum credential description (10-bit length) |
| MaxAttestContent | 2047 bytes | Maximum attestation content (11-bit length) |
| MaxFreeData | 255 bytes | Maximum Coinbase free data |

### 8.2 Fee Calculation（费用计算）

Transaction fees are implicitly calculated:

```
Fee = Sum(input coin values) − Sum(output coin values)
```

The fee must be non-negative. Of the total fees collected in a block:

- **50% is burned** — permanently removed from circulation, providing deflationary pressure.
- **50% is distributed** — appears in the Coinbase transaction as revenue for the minting team and public services.

### 8.3 Transaction Priority（交易优先级）

Block inclusion follows these priority rules:

1. **Earlier input timestamps** — transactions referencing older UTXOs are preferred.
2. **Higher coin-age burn or higher fees** — secondary tiebreaker.


## 9. Hash Tree in Block（区块内的哈希校验树）

All transactions in a block are organized into a Merkle-like binary hash tree:

```
TxTreeRoot = BinaryTree( [3B_seq || TxID_0], [3B_seq || TxID_1], ..., [3B_seq || TxID_N] )
```

- Each leaf is a TxID prefixed with a 3-byte sequence number for positional identification.
- The sequence prefix enables random access extraction and verification of any transaction by position.
- The tree root feeds into `CheckRoot` computation along with the UTXO fingerprint.

This design supports the block publication optimization: during block synchronization, only 16-byte TxID prefixes are initially broadcast. Recipients compare against their local transaction pool and request only missing transactions.


## 10. Summary of Hash Relationships（哈希关系总结）

```
                    ┌─────────────────────────┐
                    │      Block Header       │
                    │  ┌───────────────────┐  │
                    │  │    CheckRoot      │  │
                    │  └────────┬──────────┘  │
                    └───────────┼──────────────┘
                                │
                    ┌───────────┴──────────┐
                    │                      │
              ┌─────┴─────┐      ┌─────────┴─────────┐
              │ TxTreeRoot│      │  UTXO Fingerprint  │
              └─────┬─────┘      └─────────┬──────────┘
                    │                      │
          ┌────────┬┴───────┐        ┌─────┴─────┐
          │        │        │        │  4-Level   │
       TxID_0   TxID_1   ...        │  Year→Tx→  │
          │                          │  Out→Hash  │
    ┌─────┴─────┐                    └────────────┘
    │  TxHeader │
    │ ┌───────┐ │
    │ │HashBody│ │
    │ └───┬───┘ │
    └─────┼─────┘
          │
    ┌─────┴──────┐
    │            │
InputHash    OutputHash
    │            │
┌───┴───┐    BinaryTree
│       │    (outputs)
LeadHash RestHash
```

**Key invariants**:

- `TxID = SHA-512( TxHeader )` — signatures excluded.
- `HashBody = SHA-512( InputHash || OutputHash )` — body integrity.
- `CheckRoot = SHA-512( TxTreeRoot || UTXOFingerprint )` — block integrity.
- UTXO fingerprint uses the UTXO set **before** applying the current block's transactions.
- All hash operations use SHA-512 (64 bytes) except attachments (BLAKE3) and public key hashes (SHA-384, 48 bytes).
