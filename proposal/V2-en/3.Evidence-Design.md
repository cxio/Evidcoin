# Evidence Design Proposal（信元设计提案）

## 1. Overview（概述）

This proposal defines the three fundamental evidence units (信元, "Evidence Units") in Evidcoin: **Coin**, **Credit**, and **Proof**. Together they form the building blocks of all credit expression on the chain.

A transaction is the envelope for credit expression and transfer. It consists of inputs (referencing previous unspent outputs) and outputs (defining credit content and recipients). Each output carries one type of evidence unit, governed by a locking script.

Key design principles:

- **Coin** (币金): Divisible numeric value — the currency/token of the system.
- **Credit** (凭信): Indivisible, transferable data — contracts, bonds, digital credentials.
- **Proof** (存证): Indivisible, non-transferable — existence proofs anchored on-chain.

If a transaction contains only Coins, it is a pure transfer. If it also contains Credits or Proofs, it is a mixed transaction. Since on-chain transactions require fees, Coin inputs are practically unavoidable.


## 2. Evidence Unit Definitions（信元定义）

### 2.1 Coin（币金）

Coins represent quantifiable value, analogous to currency or tokens.

**Properties:**

- Divisible, mergeable, and subject to arithmetic operations.
- Original creation occurs exclusively via the Coinbase (minting) transaction.
- Amounts are expressed as variable-length integers in the smallest unit (`chx`).

**Output structure (pseudo-Go):**

```go
// CoinOutput 表示一个币金输出。
type CoinOutput struct {
    Receiver   []byte  // 接收者地址（公钥哈希，48 字节），或 null 表示销毁
    Amount     int64   // 币金数量，最小单位 chx
    Memo       []byte  // 附言，可选，最长 255 字节
    LockScript []byte  // 锁定脚本，最长 1024 字节
}
```

**Special address — `null`:** Paying to the null address destroys coins. Outputs sent to null are excluded from the UTXO set.

### 2.2 Credit（凭信）

Credits represent indivisible, transferable credentials — contracts, bonds, certificates.

**Properties:**

- Cannot be split, but can be transferred (similar to spending a Coin).
- May optionally allow description revision upon transfer.
- Untransferred Credits reside in the UTXO set.
- Anyone can create a Credit (like an ordinary transaction).

**Output structure (pseudo-Go):**

```go
// CreditOutput 表示一个凭信输出。
type CreditOutput struct {
    Receiver     []byte  // 接收者地址（48 字节公钥哈希）
    Creator      []byte  // 创建者标识或引用（< 256 字节）
    Config       uint16  // 2 字节配置位域（见下文）
    Title        []byte  // 标题，人类可读（< 256 字节）
    Description  []byte  // 描述（长度由 Config 低 10 位指定，< 1024 字节）
    AttachmentID []byte  // 附件 ID，可选（< 256 字节，含结构）
    LockScript   []byte  // 锁定脚本
}
```

**Config bit layout (2 bytes):**

| Bit(s) | Name | Description |
|--------|------|-------------|
| 15 | `NEW` | New-creation flag. Set when the Credit is initially created. |
| 14 | `MUTABLE` | Whether the description may be revised upon transfer. |
| 13 | `MODIFIED` | Set when the description has been revised in this transfer. |
| 12 | (reserved) | — |
| 11 | `HAS_XFER_COUNT` | Followed by a 2-byte transfer-count limit. |
| 10 | `HAS_EXPIRY` | Followed by a 4-byte expiry duration (seconds). |
| 0–9 | `DESC_LEN` | Description content length (< 1024 bytes). |

Transfer count and expiry may coexist; whichever limit is reached first terminates the Credit. An expired Credit is removed from the UTXO set but remains on-chain (like a Proof).

### 2.3 Proof（存证）

Proofs represent static existence declarations — copyright claims, certificates, sub-chain anchors, topic indexes, or application entry points.

**Properties:**

- Cannot be split or transferred.
- Cannot serve as transaction inputs.
- Anyone can create a Proof.

**Output structure (pseudo-Go):**

```go
// ProofOutput 表示一个存证输出。
type ProofOutput struct {
    Creator      []byte  // 创建者标识（< 256 字节），可为空
    Title        []byte  // 标题（< 256 字节），人类可读
    Content      []byte  // 内容，通常为文本（长度由 ContentLen 指定，最大 2048 字节）
    ContentLen   uint16  // 2 字节，低 11 位为内容字节长度
    AttachmentID []byte  // 附件 ID，可选
    IdentScript  []byte  // 识别脚本，供程序化识别和处理
}
```

**ContentLen bit layout (2 bytes):**

| Bit(s) | Name | Description |
|--------|------|-------------|
| 11–15 | (reserved) | — |
| 0–10 | `CONTENT_LEN` | Content length in bytes (max 2048). |

Since Proofs are non-transferable, the IdentScript serves a different purpose from locking scripts — it enables third-party clients to programmatically recognize and process the Proof via script jump instructions (e.g., `GOTO`).


## 3. Output Configuration Byte（输出项配置字节）

Every transaction output carries a 1-byte configuration header.

```go
// OutputConfig 输出项配置（1 字节）。
// 高 4 位为标记位，低 4 位为类型值。
type OutputConfig byte

const (
    OutCustomClass  OutputConfig = 1 << 7 // 自定义类：余下 7 位为类 ID 长度
    OutHasAttach    OutputConfig = 1 << 6 // 包含附件
    OutDestroy      OutputConfig = 1 << 5 // 销毁标记
    // bit 4: reserved

    OutTypeCoin     OutputConfig = 1  // 币金
    OutTypeCredit   OutputConfig = 2  // 凭信
    OutTypeProof    OutputConfig = 3  // 存证
    OutTypeMediator OutputConfig = 4  // 介管脚本
)
```

| Bit | Flag | Description |
|-----|------|-------------|
| 7 | `CustomClass` | When set, remaining 7 bits encode a private class-ID length (max 127 bytes). |
| 6 | `HasAttachment` | Declares an attachment is present. Re-purposed if `CustomClass` is set. |
| 5 | `Destroy` | Burns the Coin or terminates a Credit's transferability. Output excluded from UTXO. |
| 4 | (reserved) | — |
| 3–0 | `Type` | `0` reserved, `1` Coin, `2` Credit, `3` Proof, `4` Mediator. |

**Destroy semantics:** When set, the receiver may be `null`. The locking script may be empty or contain a single `NIL`, though meaningful scripts are allowed.

**Mediator (介管):** A special output type that cannot be used as a transaction input. It is referenced only via script jump instructions (e.g., `GOTO`) from other transactions, enabling intermediary/supervisory logic (e.g., regulatory auditing scripts).

**Custom Class (自定义类):** Enables private application-specific scripts with extended instructions. Custom outputs cannot serve as UTXO inputs. Up to 127 bytes of private identifier anchor the specialized client.


## 4. Attachment System（附件系统）

Attachments extend Credits and Proofs with arbitrarily large data stored off-chain via the Depots (数据驿站) P2P network. Only an Attachment ID is embedded in the transaction output.

### 4.1 Attachment ID Structure（附件 ID 结构）

```go
// AttachmentID 附件 ID 结构（< 256 字节总长）。
type AttachmentID struct {
    TotalLen       uint8    // ID 总长（1 字节）
    MajorType      uint8    // 附件大类（1 字节，参考 MIME）
    MinorType      uint8    // 附件小类（1 字节）
    FingerprintLen uint8    // 指纹强度：按 4 字节增量（0=>16, 1=>20, ..., 12=>64）
    Fingerprint    []byte   // BLAKE3 哈希（最低 128 bit / 16 字节）
    ShardCount     uint16   // 分片数量（< 65536）
    ShardTreeRoot  [48]byte // 片组哈希树根（二元结合，叶子含 2 字节序号前缀）
    Size           int64    // 附件大小（变长整数，单位：字节）
}
```

**Key points:**

- **Hash algorithm:** BLAKE3 is used for attachment fingerprints — chosen for its speed and streaming capability, distinct from the SHA-512 used for transaction/block hashing.
- **Fingerprint length** is user-selected (minimum 128-bit), encoded as a 4-byte increment index.
- **Shard tree:** A binary hash tree (Merkle-like). Each leaf is the 48-byte hash of a shard's data, prefixed with a 2-byte sequence number (total 50 bytes per leaf). The sequence prefix is applied by the verifier, preventing source-node tampering.
- With a max shard size of 2 MB and up to 65,535 shards, attachments can represent up to ~128 GB.

### 4.2 Shard Verification（分片验证）

To verify a single shard without downloading the entire attachment:

1. Request the shard data and its Merkle proof path from the source node.
2. Compute the BLAKE3 hash of the received shard data.
3. Prefix the hash with the 2-byte sequence number (verifier-controlled, not source-provided).
4. Combine with the proof path hashes to recompute the shard tree root.
5. Compare with the `ShardTreeRoot` in the Attachment ID.

### 4.3 Shard Count Rules（分片数量规则）

| `ShardCount` | Meaning |
|---|---|
| `0` | No sharding. `ShardTreeRoot` is all zeros (meaningless). |
| `1` | Logically unsharded. `ShardTreeRoot` equals the BLAKE3 hash of the full attachment. |
| `> 1` | Sharded. `ShardTreeRoot` computed from the ordered shard hash tree. |

### 4.4 Attachment Size（附件大小）

Attachment size is declared but not enforced by blockchain nodes — the chain cannot verify off-chain data sizes. Misrepresenting the size may reduce the willingness of Depot nodes to store the data (viewed as misbehavior or data corruption).


## 5. Signature Scheme（签名方案）

Ownership of outputs is proved via digital signatures, the standard built-in verification method.

### 5.1 Single Signature（单签名）

The common case: a single private key signs the transaction to authorize spending.

```go
// SingleSigUnlock 单签名解锁数据。
type SingleSigUnlock struct {
    Signature []byte  // 签名
    PublicKey []byte  // 对应的公钥
}
```

### 5.2 Multi-Signature（多重签名）

Supports an `M-of-N` scheme for enhanced social security and flexibility.

- **N**: Total number of participating public keys.
- **M**: Minimum number of signatures required (M ≤ N).
- The `m/N` ratio is encoded as 2 bytes (`1+1`), supporting up to `255/255`.

**Multi-sig address construction:**

```go
// 多重签名地址构造流程
// 1. 对 N 个公钥分别计算 SHA-384 哈希
//    PKH_i = SHA384(pubKey_i)
// 2. 公钥哈希有序串连，前置 m/N 配比
//    PKHs = SHA384( [m, N] || PKH_1 || PKH_2 || ... || PKH_N )
// 3. PKHs 编码为文本形式即为多签地址
```

Privacy property: Multi-sig addresses are visually indistinguishable from single-sig addresses. Participants only need to share their public-key hashes (not raw public keys), enhancing security and enabling anonymous participation.

**Multi-sig unlock data:**

```go
// MultiSigUnlock 多重签名解锁数据。
type MultiSigUnlock struct {
    Signatures [][]byte  // m 个签名
    PublicKeys [][]byte  // m 个对应公钥
    Complement [][]byte  // N-m 个未参与签名的公钥哈希
}
// m/N 配比可由 len(PublicKeys) 和 len(Complement) 推算。
```

**Multi-sig verification procedure:**

1. Derive `m` and `N` from the unlock data sizes.
2. Hash each provided public key: `PKH_i = SHA384(pubKey_i)`.
3. Merge with the complement hashes, sort, concatenate, prefix with `[m, N]`, and compute the composite hash.
4. Compare with the receiver's public-key hash stored in the output.
5. Verify each of the `m` signatures.


## 6. Authorization Flags（授权标志）

A 1-byte flag configures which parts of the transaction the signature covers, enabling flexible authorization modes.

```go
// SigFlag 签名授权标志（1 字节）。
type SigFlag byte

const (
    // 独项（self-contained）
    SIGIN_ALL    SigFlag = 1 << 7  // 全部输入项
    SIGIN_SELF   SigFlag = 1 << 6  // 仅当前输入项

    // 主项（primary, requires auxiliary）
    SIGOUT_ALL   SigFlag = 1 << 5  // 全部输出项
    SIGOUT_SELF  SigFlag = 1 << 4  // 与当前输入同序位的输出项

    // 辅项（auxiliary, requires primary）
    SIGRECEIVER  SigFlag = 1 << 0  // 输出的接收者
    SIGCONTENT   SigFlag = 1 << 1  // 输出内容（Coin: amount/memo; Credit: creator/config/title/desc/attachID）
    SIGSCRIPT    SigFlag = 1 << 2  // 输出的锁定脚本
    SIGOUTPUT    SigFlag = 1 << 3  // 完整输出条目（receiver + content + script）
)
```

**Combination rules:**

| Category | Rule | Example |
|----------|------|---------|
| Independent | Can be used alone or combined with others. | `SIGIN_ALL` |
| Primary | Must combine with an auxiliary flag. | `SIGOUT_ALL \| SIGRECEIVER` |
| Auxiliary | Must combine with a primary flag. | `SIGOUT_SELF \| SIGOUTPUT` |

**Most common configuration:** `SIGIN_ALL | SIGOUT_ALL | SIGOUTPUT` — signs all inputs and the complete data of all outputs.

**Flexible authorization examples:**

- `SIGIN_ALL | SIGOUT_SELF | SIGOUTPUT` — all inputs + only the output at the same index.
- `SIGIN_SELF | SIGOUT_ALL | SIGRECEIVER` — only the signer's own input + all output receivers.


## 7. Signature Separation（签名分离机制）

Signatures are **excluded** from the `TxID` computation. This is a deliberate design choice with significant implications.

### 7.1 TxID Computation（TxID 计算）

```go
// TxHeader 交易头结构。
type TxHeader struct {
    Version   int      // 版本号
    Timestamp int64    // 交易时间戳（Unix 纳秒）
    HashBody  [64]byte // 数据体哈希（SHA-512）
}

// TxID = SHA512(TxHeader)
// HashBody = SHA512(InputHash || OutputHash)
//
// 签名数据不参与 HashBody 计算，因此不影响 TxID。
```

### 7.2 Rationale（设计理由）

1. **Malleability resistance:** Since signatures are not part of the TxID, third parties cannot alter the TxID by modifying the signature (eliminating the transaction malleability issue that affected early Bitcoin).
2. **Signature discardability:** Signatures are verified at block inclusion time. Once a block is confirmed and its position secured by the dual-chain coupling (block-ID chain + UTXO fingerprint chain), signatures can be safely discarded to reclaim storage.
3. **Long-term security:** After signature disposal, the chain's integrity rests on the dual-chain coupling mechanism rather than on persisted signatures. This provides post-quantum resilience — even if signature algorithms are broken in the future, the chain history remains tamper-proof.

### 7.3 Dual-Chain Coupling（双链耦合）

Long-term chain integrity is maintained by two interlocking hash chains:

- **Block-ID Chain (区块 ID 链):** Each block header includes the previous block's hash, forming a sequential chain.
- **UTXO Fingerprint Chain (UTXO 指纹链):** Each block commits to the cumulative UTXO state, creating a parallel integrity chain.

Together, these chains provide cryptographic proof that neither blocks nor their contained transactions have been altered, independent of signature data.


## 8. Public-Key Hash and Address Format（公钥哈希与地址格式）

### 8.1 Public-Key Hash（公钥哈希）

- **Algorithm:** SHA-384 (48 bytes).
- **Rationale:** Shorter than SHA-512 because UTXO entries are transient — they exist only until spent. The 384-bit security level is sufficient for the UTXO lifetime while saving storage in the frequently-accessed UTXO set.

```go
const PubKeyHashLen = 48 // SHA-384 输出长度（字节）

// PubKeyHash 计算公钥哈希。
// pkh = SHA384(publicKey)
type PubKeyHash [48]byte
```

### 8.2 Address Encoding（地址编码）

Addresses are human-readable text representations of public-key hashes.

**Encoding procedure:**

1. Prepend a network-specific identification prefix to the public-key hash: `prefix || PKH`.
2. Hash the result and take the last 4 bytes as the **checksum**.
3. Append the checksum to the raw public-key hash (without prefix): `PKH || checksum`.
4. Encode the byte sequence as text (likely a modified Base32 encoding).
5. Prepend the identification prefix to produce the final address: `prefix + encodedText`.

**Verification procedure:**

1. Strip the prefix, decode the text portion to bytes.
2. Split into the public-key hash (first 48 bytes) and the checksum (last 4 bytes).
3. Recompute: hash `prefix || PKH`, take the last 4 bytes.
4. Compare. Match indicates a valid address.

```go
// Address 地址结构示意。
type Address struct {
    Prefix  string       // 网络识别前缀
    PKHash  PubKeyHash   // 48 字节公钥哈希
    Check   [4]byte      // 校验码
}

// Encode 将地址编码为可读文本。
// result = Prefix + Base32(PKHash || Check)
func (a *Address) Encode() string { /* ... */ }

// Verify 校验地址的完整性。
func (a *Address) Verify() bool { /* ... */ }
```

**Privacy:** Single-sig and multi-sig addresses are visually identical, preventing observers from distinguishing account types.


## 9. Evidence Lifecycle Management（信元生命周期管理）

### 9.1 Coin Lifecycle（币金生命周期）

```
 [Coinbase Minting] ──► [UTXO Set] ──► [Spent as Input] ──► [New Outputs]
                            │
                            └──► [Destroy Flag / null Address] ──► [Removed from UTXO]
```

1. **Creation:** Coins are created exclusively by Coinbase transactions.
2. **Existence:** Unspent Coins reside in the UTXO set.
3. **Spending:** A valid unlock script consumes the Coin from the UTXO set and creates new outputs.
4. **Destruction:** Setting the `Destroy` flag or paying to the `null` address permanently removes Coins from circulation.

### 9.2 Credit Lifecycle（凭信生命周期）

```
 [Creation (NEW flag)] ──► [UTXO Set] ──► [Transfer] ──► [UTXO Set (new owner)]
      │                         │               │
      │                         │               └──► [Revision if MUTABLE]
      │                         │
      │                         ├──► [Destroy Flag] ──► [Removed from UTXO]
      │                         │
      │                         └──► [Expiry / Transfer-count exhausted]
      │                                    │
      │                                    └──► [Removed from UTXO, remains on-chain]
      │
      └──► [Mutability: can transition MUTABLE → IMMUTABLE (one-way)]
```

1. **Creation:** Anyone can create a Credit. The `NEW` flag (bit 15) is set. The creator decides mutability.
2. **Transfer:** Similar to spending a Coin. The Credit is consumed from the UTXO set and re-created with a new owner.
   - If `MUTABLE`: the description may be revised; the `MODIFIED` flag must be set.
   - If immutable: only the receiver and locking script may change; the creator field becomes a reference.
3. **Mutability transition:** A Credit may transition from mutable to immutable (one-way, irreversible).
4. **Expiry:** Checked passively during transfer validation. When a Credit's expiry time or transfer count is exhausted, it is removed from the UTXO set. An expired Credit remains on-chain as historical data.
5. **UTXO cleanup:** When all outputs of the source transaction are spent, associated expired Credits are fully removed from the UTXO set.
6. **Destruction:** Setting the `Destroy` flag terminates transferability.

**Compliance checks on transfer:**

| Condition | Allowed Changes |
|---|---|
| Immutable | Receiver, locking script only. Creator becomes a reference. |
| Mutable + Modified | Description may change. `MODIFIED` flag must be set. |
| Mutable → Immutable | One-way lock-down of mutability. |

### 9.3 Proof Lifecycle（存证生命周期）

```
 [Creation] ──► [On-chain (permanent)]
                    │
                    └──► [Referenced via IdentScript / GOTO]
```

1. **Creation:** Anyone can create a Proof. It is written on-chain permanently.
2. **Immutability:** Once created, a Proof is never modified or transferred.
3. **No UTXO presence:** Proofs do not enter the UTXO set (they cannot be spent).
4. **Referencing:** Other transactions' scripts may reference a Proof via its IdentScript using jump instructions (e.g., `GOTO`), enabling programmatic discovery by third-party clients.

### 9.4 Lifecycle Summary（生命周期总结）

| Property | Coin | Credit | Proof |
|---|---|---|---|
| Divisible | Yes | No | No |
| Transferable | Yes (spending) | Yes (transfer) | No |
| In UTXO set | Yes | Yes (until expired/destroyed) | No |
| On-chain permanent | Yes | Yes | Yes |
| Can be destroyed | Yes (null/Destroy) | Yes (Destroy/expiry) | N/A |
| Created by | Coinbase only | Anyone | Anyone |
| Has locking script | Yes | Yes | No (has IdentScript) |
| Supports attachment | No | Yes | Yes |


## 10. Design Considerations（设计考量）

### 10.1 UTXO Efficiency（UTXO 效率）

- Public-key hashes use SHA-384 (48 bytes) rather than SHA-512 (64 bytes), reducing UTXO entry size.
- Credit expiry is checked passively — only when a transfer is attempted — avoiding unnecessary scans.
- Proofs never enter the UTXO set, keeping it compact.

### 10.2 Privacy（隐私）

- Single-sig and multi-sig addresses are indistinguishable in appearance.
- Multi-sig participants share only public-key hashes, not raw public keys.
- Custom-class outputs provide private application channels over the public network.

### 10.3 Extensibility（可扩展性）

- The output configuration byte reserves bits for future use.
- Custom-class outputs support up to 127 bytes of private class identifiers.
- Mediator outputs enable cross-transaction script composition for complex workflows (auditing, regulatory compliance).
- Attachment sharding and the Depot P2P network decouple large-data storage from the blockchain itself.

### 10.4 Security（安全性）

- Signature separation eliminates transaction malleability.
- Dual-chain coupling (block-ID chain + UTXO fingerprint chain) provides long-term integrity independent of signatures.
- BLAKE3 for attachments provides high-speed verification while SHA-512 secures the block/transaction layer.
- SHA-384 for public-key hashes provides 192-bit security, adequate for transient UTXO lifetimes.
