# Consensus: Proof of Historical (PoH)（共识：历史证明）

> **Design Proposal** — This document describes the consensus mechanism of Evidcoin, covering
> the Proof of Historical (PoH) algorithm, minting hash computation, Best Pool coordination,
> block minting workflow, fork resolution, bootstrap procedure, and endpoint conventions.


## 1. Overview（概述）

Evidcoin adopts **Proof of Historical (PoH)** as its consensus mechanism. Unlike Proof of Work
(PoW), which demands brute-force hash computation, or Proof of Stake (PoS), which ties influence
to wealth, PoH derives minting eligibility from **historical transaction IDs** — data that is
publicly verifiable, immutable once confirmed, and independent of any party's financial holdings.

Core properties:

| Property | Description |
|----------|-------------|
| **Fairness** | Every confirmed transaction ID carries equal weight; wealth does not amplify influence. |
| **Determinism** | Transaction IDs are fixed once included in a block; the selection input cannot be retroactively altered. |
| **Accessibility** | The only way to increase minting chances is to create more transactions, which incurs fee costs and enriches miners — a positive-sum feedback loop. |
| **Anti-shaping** | Multiple countermeasures prevent attackers from crafting transaction data to steer selection outcomes (see §2). |


## 2. Minting Hash Computation（铸凭哈希计算）

### 2.1 Terminology（术语）

| Term | Definition |
|------|------------|
| **Minting Transaction** | A historical transaction whose ID participates in the minting competition. The eligible block range is `[Height-80000, Height-25]` (~11 months). |
| **Minter** | The address that *spent* the first input of the minting transaction (i.e., the sender, not the receiver). Using spent addresses avoids cold-mining incentives. |
| **Reference Block** | The block at `Height - 9`, whose minting hash and UTXO fingerprint contribute to the computation. |
| **UTXO Fingerprint** | A digest representing the UTXO set state after a given block's transactions are applied. |

### 2.2 Anti-Shaping Measures（防塑造措施）

Hash shaping is an attack where an adversary injects arbitrary data into hash inputs to bias
the output toward a desired target. PoH defends against this through careful factor selection:

1. **Tail exclusion** — Transactions in blocks `[-1, -24]` are excluded because their creators
   already know the reference block parameters at creation time and could shape their IDs.
2. **Block ID exclusion** — The reference block's own ID is excluded because the minter can
   manipulate the Coinbase data and transaction ordering.
3. **UTXO fingerprint from a deeper block** — The UTXO fingerprint is taken from block
   `Height - 24` (not the reference block itself), so the reference block's minter is unknown
   at the time the UTXO state is determined, making fingerprint shaping infeasible without
   first predicting the minter.
4. **Signature blinding** — The hash input is signed with the minter's private key before the
   final hash, so an attacker without the private key cannot predict the minting hash for any
   given minting transaction.

### 2.3 Algorithm（算法）

```go
// MintingHash 计算铸凭哈希。
// txID:           铸凭交易 ID
// refMintHash:    评参区块（Height-9）的铸凭哈希
// utxoFP:         第 Height-24 区块的 UTXO 指纹
// blockTimestamp:  当前区块时间戳（由公式计算，非本地时钟）
// privateKey:     铸造者的私钥
func MintingHash(txID Hash512, refMintHash Hash512, utxoFP Hash512,
    blockTimestamp int64, privateKey PrivateKey) Hash512 {

    // 阶段一：组装源数据并哈希
    source := concat(txID, refMintHash, utxoFP, encodeInt64(blockTimestamp))
    hashData := SHA512(source)

    // 阶段二：用铸造者私钥签名（结果对外不可预测）
    signData := Sign(privateKey, hashData)

    // 阶段三：对签名结果取哈希，得到铸凭哈希
    return SHA512(signData)
}
```

**Selection criterion**: Minting hashes are compared as byte sequences; the **smallest** value wins.


## 3. Best Pool Mechanism（择优池机制）

### 3.1 Structure（结构）

The Best Pool is a ranked buffer of minting candidates for a specific reference block. Each
node maintains a pool set — one pool per upcoming reference block.

```go
const BestPoolCapacity = 20

// BestPool 择优池：按铸凭哈希升序排列的铸造候选者集合。
type BestPool struct {
    RefHeight   int             // 对应的评参区块高度
    Candidates  [BestPoolCapacity]MintCandidate  // 按铸凭哈希升序排列
    Size        int             // 当前候选者数量
}

// MintCandidate 择优凭证：铸造候选者的证明信息。
type MintCandidate struct {
    TxYear    int       // 交易所在年度
    TxID      Hash512   // 铸凭交易 ID
    MinterPub PublicKey // 铸造者公钥（首笔输入的接收者）
    SignData  []byte    // 铸造者对铸凭哈希源数据的签名
    MintHash  Hash512   // 铸凭哈希（由 SignData 计算）
}
```

### 3.2 Insertion Rule（插入规则）

When a new minting transaction proof arrives:

1. Compute its minting hash.
2. If the pool is not full, insert in sorted order and relay.
3. If the pool is full, compare with the worst (largest) entry; if better, replace, insert in
   sorted order, and relay. Otherwise, discard silently.

### 3.3 Pool Lifecycle（池生命周期）

A Best Pool progresses through three phases relative to its reference block's journey toward
the `-9` position:

| Phase | Block Position | Duration | Activity |
|-------|---------------|----------|----------|
| **Broadcast & Collect** | From creation to `-7` | 6 block intervals (~36 min) | Nodes compute minting hashes, broadcast proofs, and populate pools. Nodes also exchange pool state to optimize membership. |
| **Sync & Optimize** | `-7` to `-9` | 2 block intervals (~12 min) | Pool updates cease. Authorized nodes synchronize pools across the network. |
| **Locked** | Reaches `-9` | — | Pool is finalized. The reference block's candidates are determined. |

### 3.4 Sync Protocol（同步协议）

#### Authorized Nodes（授权节点）

Only the **bottom 15** candidates (ranks 6–20) in the Best Pool may initiate synchronization.
This is based on the principle of interest-irrelevance: top-ranked candidates have incentive to
exclude better late arrivals, while lower-ranked nodes have no such motivation. Each authorized
node may perform synchronization **only once**.

#### Sync Process（同步流程）

1. An authorized node signs its current Best Pool (called the **Sync Pool**) and broadcasts it.
2. Receiving nodes create a **Merge Pool** and validate incoming Sync Pools:
   - The signer must exist in the receiver's own Best Pool *or* in the Merge Pool (relaxed for
     first-time sync of newly online nodes).
   - The signer must be in the bottom 15 of the Sync Pool they are publishing.
3. After validation, entries are merged into the Merge Pool.
4. Upon completion of the sync phase, the Merge Pool replaces the node's Best Pool for that
   reference block.

### 3.5 Minter Legitimacy Verification（铸造者合法性验证）

To verify that a minting candidate is legitimate:

1. Retrieve the first input data and transaction header (containing the lead-input hash) by
   the claimed transaction ID.
2. Compute `LeadHash` from the first input data.
3. Confirm `LeadHash` matches the lead-input hash in the transaction header.
4. Confirm the public key in the first input matches the public key in the minting credential.
5. Recompute the transaction ID from the header, request the associated Merkle branch, and
   verify the transaction's inclusion in its block. (Every client maintains the block header chain.)


## 4. Block Minting Workflow（区块铸造流程）

### 4.1 Block Time（出块时间）

Block time is **fixed at 6 minutes**. Timestamps are not stored in the block header but are
computed deterministically:

```go
const BlockInterval = 6 * time.Minute

// BlockTime 按高度计算区块时间戳。
func BlockTime(genesisTimestamp int64, height int) int64 {
    return genesisTimestamp + int64(height) * int64(BlockInterval)
}
```

Genesis block information (timestamp, initial parameters) is hardcoded into the client.

### 4.2 Block Header（区块头）

```go
type Hash512 = [64]byte

// BlockHeader 区块头结构。
type BlockHeader struct {
    Version   int      // 版本号
    PrevBlock Hash512  // 前一区块哈希
    CheckRoot Hash512  // Hash(交易哈希树根 + UTXO 指纹)，附铸造者签名
    Stakes    int      // 币权销毁量（币天）
    Height    int      // 区块高度
    YearBlock Hash512  // 前一年块哈希（仅当 Height % 87661 == 0 时有效）
}
```

Key fields:

- **CheckRoot**: `Hash(MerkleRoot(TxIDs) + UTXO_Fingerprint)`. The "signature" in the block
  header is the minter's signature over this CheckRoot, stored in the Coinbase transaction as
  the minting credential.
- **Stakes**: Aggregate coin-day destruction across all transactions in the block. Coin-days =
  unspent output amount x holding days; destroyed (reset to zero) upon spending.
- **YearBlock**: When `Height % 87661 == 0`, this field references the previous year-block hash,
  enabling efficient long-range chain verification without requiring full header storage.

### 4.3 Minting Sequence（铸造序列）

When the block timestamp approaches:

1. **+30 seconds**: The top-ranked candidate (rank 1) publishes their block. The 30-second
   delay after the canonical timestamp allows maximum transaction collection.
2. **+15 seconds per rank**: Each subsequent candidate publishes at 15-second intervals
   (rank 2 at +45s, rank 3 at +60s, etc.).
3. **Early termination**: If a candidate receives and validates a block from a higher-ranked
   candidate before their turn, they do not publish.

All 20 pool members *may* publish, but in practice only 1–2 blocks propagate due to the
staggered schedule.

### 4.4 Block Acceptance（区块接受）

A node accepts a block if:

1. The block is structurally valid (correct PrevBlock, valid CheckRoot, etc.).
2. The minter is a member of the finalized Best Pool for the current height.
3. No block competition rule (§4.5) overrides acceptance.

#### Fast Relay Strategy（快速转播策略）

Full block validation can be deferred:

1. If the Coinbase is valid and a partial Merkle proof confirms the block header, relay immediately.
2. Sync the full transaction ID list; request and verify any missing transactions.
3. Recompute the full Merkle tree to confirm the block header, completing validation.

Candidates must **not** stop publishing until full validation of a superior block is complete.

### 4.5 Block Competition（区块竞争）

When multiple valid blocks exist at the same height:

| Scenario | Rule |
|----------|------|
| Same minter, multiple blocks | The block with **lower** total transaction fee wins (discourages multi-signing). |
| Different minters (redundant publish) | A challenger block wins only if its coin-day destruction exceeds the leading block's by **3x or more** (constrains transaction volume manipulation). |


## 5. Fork Resolution（分叉解决）

### 5.1 Fork Detection（分叉检测）

During node-to-node communication, peers exchange current block IDs. If different IDs appear
at the same height, a fork is detected.

### 5.2 Competition Window（竞争窗口）

- Forks must grow to **25 blocks** (~150 minutes) before evaluation.
- Block-by-block comparison: at each height, the minting hash from the Coinbase is compared.
  The fork that wins the **majority** (13+ out of 25) of these comparisons is the main chain.
- If a fork has already exceeded 25 blocks when discovered (stealth fork), it is treated as a
  separate legitimate side-chain and ignored by the main chain.

```go
const ForkWindowSize = 25

// ResolveFork 分叉评比：逐区块比较铸凭哈希。
// 返回 true 表示 challenger 胜出。
func ResolveFork(main, challenger [ForkWindowSize]Hash512) bool {
    wins := 0
    for i := 0; i < ForkWindowSize; i++ {
        if bytes.Compare(challenger[i], main[i]) < 0 {
            wins++
        }
    }
    return wins > ForkWindowSize/2 // 过半胜出
}
```

### 5.3 Fork Handling Strategy（分叉处理策略）

1. Cache all known forks.
2. Continuously evaluate minting hashes as new blocks arrive; switch to the fork with more wins.
3. When one fork achieves majority (13/25), declare it the main chain.
4. Transactions unique to the abandoned fork are recycled into the mempool for re-inclusion.

### 5.4 Confirmation Safety（确认安全性）

Because fork competition is strictly limited to the most recent 25 blocks:

- **A transaction confirmed by 25+ blocks is final** — no fork can undo it.
- New coins (Coinbase outputs) require 25 block confirmations before they can be spent. This
  is enforced at spending time, not at the block level, so no special fork-coordination logic
  is needed. If a fork is abandoned, its Coinbase outputs simply become invalid, and other
  transactions are recycled.

### 5.5 Manual Chain Switching（手动链切换）

If a network partition lasts longer than 2.5 hours, the 25-block competition window closes and
both chains become independently legitimate. In this case, clients allow users to manually
select their preferred chain by connecting to nodes on the target fork and syncing the
post-fork block header chain.


## 6. Bootstrap Procedure（引导启动）

### 6.1 Early-Stage Rules（初段规则）

The first blocks lack the full `-9` reference block history. Special rules apply:

#### Reference Block Selection（评参区块选择）

```go
// RefBlockHeight 获取评参区块高度。
func RefBlockHeight(currentHeight int) int {
    if currentHeight < 9 {
        return 0 // 使用创世块作为评参区块
    }
    return currentHeight - 9
}
```

#### Minting Transaction Eligibility（铸凭交易合法性）

```go
// IsMintTxEligible 判断铸凭交易是否在合法区块范围内。
func IsMintTxEligible(currentHeight, txHeight int) bool {
    if currentHeight < 25 {
        return true // 初段：所有合法交易均可参与
    }
    depth := currentHeight - txHeight
    return depth > 24 && depth <= 80000
}
```

### 6.2 Hundred-Day Expansion Plan（百日扩张方案）

A phased bootstrap plan to distribute initial coins and build the minting transaction base:

| Phase | Block Range | Duration | Purpose |
|-------|-------------|----------|---------|
| **Genesis** | Block 0 | — | Chain creation. |
| **Key Expansion** | Blocks 1–10 | ~1 hour | Create multiple receiving addresses for future transactions and minting competition. |
| **Accumulation** | Blocks 11–7200 | ~30 days | Observe chain operation; reserve the right to halt if issues arise. |
| **Lottery Expansion** | Blocks 7201–24000 | ~70 days | Community-driven address collection and reward distribution to expand the minting transaction pool. |
| **Open Market** | Block 24001+ | Ongoing | Public services begin; external rewards activated. Normal free-market operation commences. |

Constraints during the bootstrap period:

- Coinbase transactions contain only a single output (no public service rewards).
- Each transaction's output count must not exceed **2x** its input count, throttling expansion speed.


## 7. Endpoint Conventions（端点约定）

### 7.1 Convention Types（约定类型）

| Type | Chinese | Enforcement | Description |
|------|---------|-------------|-------------|
| **Protocol** | 协议 | Strict; violation = invalid | Rules with final verification mechanisms. Non-compliance breaks the system. |
| **Convention** | 共约 | Voluntary; unverifiable | Soft guidelines followed by goodwill. Minor non-compliance is non-fatal. |

### 7.2 Minimum Transaction Fee（最低交易费）— Convention

Calculated every 6,000 blocks (~25 days):

```go
const FeeRecalcPeriod = 6000

// MinTransactionFee 计算最低交易费（共约）。
func MinTransactionFee(avgFeeLastPeriod int64) int64 {
    return avgFeeLastPeriod / 4
}
```

This is a **convention** — the minter ultimately decides whether to include low-fee transactions.
However, nodes must **not** block relay of low-fee transactions, since the minter may have
already included them and other nodes need to validate the block.

### 7.3 Transaction Expiry（交易过期）— Protocol

Unconfirmed transactions expire after **240 blocks** (24 hours), measured by the transaction's
own timestamp. This is a **protocol** rule — minters must not include expired transactions.

Purpose:
1. Bound the size of the unconfirmed transaction pool.
2. Provide temporal determinism for applications that rely on finality.

### 7.4 Zero-Confirmation Warning（零确认警告）

The system does not enforce zero-confirmation safety. If a double-spend is detected in the
mempool, a warning is displayed to the user. For significant amounts, users should wait for
sufficient block confirmations.

### 7.5 Network Announcement（全网通告）

A minimal centralized mechanism is retained for network-wide text-only announcements. Messages
are signed by authorized keys (built into the official client or published via community
channels). Functional extensions (e.g., clickable upgrade links) are explicitly prohibited.

### 7.6 Coin-Day Destruction（币权销毁）

Coin-days measure the "stake duration" of unspent outputs:

```go
// CoinDays 计算币权（币天）。
// amount:    未花费输出的金额
// holdDays:  持有天数
func CoinDays(amount int64, holdDays int) int64 {
    return amount * int64(holdDays)
}
// 花费后币权归零。
```

Coin-day destruction is aggregated per block in the `Stakes` header field and serves as a
secondary factor in block competition (see §4.5).


## 8. Design Parameters Summary（设计参数汇总）

| Parameter | Value | Note |
|-----------|-------|------|
| Block interval | 6 minutes | Fixed; timestamps computed, not stored |
| Blocks per year | 87,661 | ≈365.25 days × 24h × 60min / 6min |
| Minting tx eligible range | `[Height-80000, Height-25]` | ~11 months lookback |
| Reference block offset | Height - 9 | For minting hash computation |
| UTXO fingerprint source | Height - 24 | Deeper than reference block for anti-shaping |
| Best Pool capacity | 20 candidates | Sorted ascending by minting hash |
| Sync-authorized members | Bottom 15 (ranks 6–20) | Interest-irrelevance principle |
| First block publish delay | +30 seconds after timestamp | Maximize transaction collection |
| Redundant publish interval | 15 seconds per rank | Staggered to minimize network flooding |
| Fork competition window | 25 blocks (~150 minutes) | Majority (13/25) wins |
| New coin confirmation depth | 25 blocks | Checked at spend time, not block level |
| Min fee recalculation period | 6,000 blocks (~25 days) | Convention, not protocol |
| Transaction expiry | 240 blocks (24 hours) | Protocol; strictly enforced |
| Hash algorithm (default) | SHA-512 (64 bytes) | Used for block hashes, tx IDs, minting hashes |
| Max stack height (script) | 256 | Script execution limit |
| Max transaction size | 8,192 bytes | Per-transaction cap |
