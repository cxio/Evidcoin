# 模式指令

对脚本进行模式匹配，以验证其是否符合特定的逻辑（形式化验证）。在匹配的过程中，可以提取信息。

模式匹配很有用，比如在链间兑换时确认对方的预支付脚本是否有效，或者中间件匹配测试提取信息，完成某些无人审核的自动化流程等。

模式匹配可以让你在具体的行动前得到某种预期性的确认。

> **注：**
> 拥有广泛共识的脚本（逻辑流）可以被预先发布作为 `GOTO` 或 `EMBED` 的目标。


## 定义

指令码区间：`[116-127]`，12个。

```go
码值    指令字          说明
-----------------------------------------------------------
116     MODEL{}(2)      创建模式匹配区
        // 开启一个解析子环境，对目标脚本执行模式匹配。
        // 附参：子块代码长度。
        // 实参：待测试的目标序列（Script|Bytes）。
        // 返回值：有两种情况：
        // - 无取值时：布尔值。表达模式是否成功匹配。
        // - 有取值时：切片, 布尔值。返回两个值，首个成员为取值的值集。
        // 说明：
        // 返回两个值时会自动展开到目标区。
        // 模式内是否有取值，在代码编写时就已知，因此并无不确定性。
        // 实现：
        // 作为一种优化，模式内是否有取值的状态会标记在附参最高位，
        // 因此子块代码最大仅支持32kb（15位）。
        // 例：
        // CODE {
        //      TOP FN_PUBHASH
        //      DATA{<hashResult>}
        //      EQUAL PASS
        //      FN_CHECKSIG PASS
        // }
        //
        // 有取值时：
        // MODEL{
        //      TOP FN_PUBHASH      // 严格匹配
        //      DATA[32]{?}         // 内容任意，但长度32字节
        //      #[64]               // 取 DATA{} 关联数据
        //      EQUAL PASS          // 严格匹配
        //      FN_CHECKSIG PASS    // 严格匹配
        // }                        //=> ([<hashResult>], true)
        // @POPS[2] OUTPUT          // 导出返回的两个值
        //
        // 无取值时：
        // MODEL{
        //      TOP FN_PUBHASH      // 严格匹配
        //      DATA[32]{?}         // 长度固定，内容任意
        //      EQUAL PASS          // 严格匹配
        //      FN_CHECKSIG PASS    // 严格匹配
        // }                        //=> true
        // PASS                     // 通关检查
        //
        // 说明：
        // 如果一个未知脚本匹配这个模型，说明其支付逻辑正常。
        //
        // 设计：
        // 普通指令在模式区内表示与目标严格相同（全匹配）。
        // 如果目标脚本包含 MODEL 块本身，其内容作为普通关联数据对待。
        // 提示：
        // 长的数据可用哈希测试相等性，这样就不必书写相同的内容。


// 以下指令仅在 MODEL{} 内有效。

117     _           指令通配
        // 目标指令可为任意指令，含附参和关联数据。
        // 但目标位置必须有指令。
        //
        // 注记：
        // 静态的指令包含指令码及其附参和关联数据。

118     _(~)        指令段通配
        // 目标可为任意指令段。
        // 附参：指令个数。
        // 例：
        // _[3]     通配目标脚本当前位置及之后共3个指令。
        // _[1]     与前面 _ 指令效果相同。
        // _[0]     没有意义。
        // 注：
        // 指令段仅指同级关系，含结构块的指令本身只是一个指令（子代码块是它的关联数据）。
        // 这是上面“_”指令的复数形式，也是后面“...”指令的高效版。

119     ?{}(~)      指令序列可选
        // 花括号包围的指令序列与目标段相同或不存在。
        // 附参：本序列长度。
        // 规则：
        // 这是一种全等测试，包含指令的附参和关联数据。
        // 如果是不存在（不同），目标位置的原指令会延续到后续的测试。
        // 例：
        // ?{ @TOP PRINT }  目标位置可包含该打印序列
        // ?{ POPS[3] }     目标位置可为一个 POPS[3] 指令
        // ?POPS[3]         同上，单个指令可无花括号
        // ?POPS            注意！这由下面的指令负责
        // ?{1, 3, 5}       匹配一个值集（单指令），可选

120     ?(1)        通配指示
        // 指示跟随指令的哪个部分可通配（与目标作比较时）。
        // 附参：位置标识。
        // 0000 0001    第1个附参任意。(1)
        // 0000 0010    第2个附参任意。(2)
        // 0000 0100    第3个附参任意。(4)
        // 0000 1000    第4个附参任意。(8)
        // 0001 0000    第5个附参任意。(16)
        // 0010 0000    关联数据任意。(32)
        // 0100 0000    指令本身可选。(64)
        // 1000 0000    关联数据的哈希匹配。(128)
        // 提示：
        // 如果附参和关联数据是同一个值（如部分值指令），用数据表达通配。
        // 可选设定时，可参看另2个“可选”模式指令。
        // 例：
        // ?[32] DATA[20]   目标为一个DATA指令，数据长度20字节，但内容任意
        // DATA[20]{?}      同上。更直观
        //
        // DATA[?]{?}       目标为一个DATA，附参和数据任意
        // ?[1|32] DATA     同上。支持位或表达，通配部分（[]{}）省略
        // ?[33] DATA       同上。33 = 1|32
        //
        // ?[1|32|64]DATA   目标为一个DATA，附参和数据任意，整体可选
        // ?[97] DATA       同上。97 = 1|32|64
        // ?DATA[?]{?}      同上。直观完整表达，首个?表达可选
        // ?DATA            同上。直观简化，未明确部分视为任意
        // ?POPS            同 ?POPS[?]，注意与 ?POPS[3] 的区别（不同模式指令）
        //
        // ""[50]{?}        匹配50字节长任意文本。
        // ?[32] ""[50]     同上，规范表达
        // ?{123}           目标是一个整数值 123，可选
        // ?{123.}          目标是一个浮点数 123.0，可选
        // ?Int             目标是一个整数，值任意，可选
        // ?Float           目标是一个浮点数，值任意，可选
        // ?Number          目标是一个数值（Int|Float），值任意，可选
        //
        // ?'A'             目标是一个A字节或符文，可选
        // !Byte            目标是一个字节，值任意
        // ?Byte            目标是一个字节，值任意，可选
        //
        // ?$               匹配局域存值指令 $，可选
        // $[?]             匹配局域取值指令 $(1)，任意位置值
        // ?$[?]            同上匹配，但可选。注意不能简化为 ?$，有冲突
        // ${?}             匹配循环变量 $X(1)，任意取值。
        //
        // 深匹配：
        // 包含子语句块的指令如果无前置通配指示，正常进入子语句块进阶测试。
        // 此时附参表达当前子块长度，而非匹配。
        // IF{...}          递进到子块内进一步测试。
        //
        // 单匹配：
        // 如果块指令有匹配指示，则视为单指令测试，子块作为关联数据对待。
        // ?[32] IF[60]     匹配if指令，子块长60字节，内容任意
        // IF[60]{?}        同上。更直观
        // IF[?]{?}         匹配if指令，长度和内容都任意。即目标位置必须为一个IF
        // ?IF              目标位置有一个IF，但可选
        //
        // ()[30]{?}        目标表达式占用30字节，内容任意
        // ()[?]{?}         目标是一个任意表达式，必须存在
        // (?)              同上。简化格式
        // ?()              目标位置有一个表达式，内容任意，可选
        // ?Expr            同上。参考下面类型匹配指令
        //
        // 哈希匹配：
        // 仅适用关联数据的严格相等测试（忽略附参）。
        // ?[128] DATA{0x4f262ae8...}   目标是一个 DATA，其内容的哈希为 4f262ae8...
        // ?[128] {0x4f262ae8...}       目标的关联数据的哈希为 0x4f262ae8...

121     #(1)        指令取值
        // 针对前一个指令匹配的目标，取目标的不同部分的值。
        // 目标需先由“通配指示”指令配置。
        // 附参：目标值标识。
        // 0000 0001 - 第1个附参。(1)
        // 0000 0010 - 第2个附参。(2)
        // 0000 0100 - 第3个附参。(4)
        // 0000 1000 - 第4个附参。(8)
        // 0001 0000 - 第5个附参。(16)
        // 0010 0000 - 关联数据。(32)
        // 0100 0000 - 单纯指令码。(64)
        // 1000 0000 - 完整指令（含附参和关联数据）。(128)
        // 说明：
        // 同一指令可取多个部分，所有的取值会按顺序展开暂存。
        // 取完整指令时，取值包含独立的附参和关联数据。
        // 本指令需紧跟在目标指令之后。
        // 例：
        // DATA[20]{?} #[32]    // 提取 DATA 目标的数据段
        // GOTO[?,?,?] #[1|2|4] // 提取 GOTO 目标的三个附参（自动展开）
        // GOTO[?,?,?] #[7]     // 同上，7 = 1|2|4
        // 提示：
        // 提取的值会放入一个内部队列，作为MODEL的第二个返回值。

122     ?!(1){Type}  类型匹配|可选
        // 目标为特定类型的指令。
        // - 匹配测试：前置!，如果失败则结束Model块。
        // - 可选测试：前置?，不会失败。
        // 附参：类型标识。
        // 类型名：
        // - Bool   布尔值（2个值指令）
        // - Byte   字节
        // - Rune   符文
        // - Int    整数
        // - BigInt 大整数（BigInt|*BigInt）
        // - Float  浮点数
        // - String 字符串（2个）
        // - Bytes  字节序列（2个）
        // - RegExp 正则表达式（RegExp|*RegExp）
        // - Time   时间类型（DATE{}）
        // - Script 脚本（Script|*Script）
        // 另支持：
        // - Dict   字典
        // - Number 整数或浮点数
        // - Expr   表达式
        // - Model  模式块（整体对待）
        // - Values 值集。如：{1, 3, 5}，由 {...}(~) 创建
        // 例：
        // !{Bool}  匹配布尔类型（true|false）
        // !Bool    同上，可省略花括号
        // ?Bool    目标是一个布尔值，可选
        //
        // !Bytes   匹配两个 DATA 指令
        // ?Bytes   同上，但可选
        // !String  匹配两个字符串指令
        // !Script  匹配 Script 或 *Script
        //
        // !Number  匹配任意整数和浮点数
        // !Model   匹配一个模式块。同：MODEL[?]{?}
        // !Expr    目标是一个表达式。同：(?)
        //
        // 实现：
        // 指令执行的是可选还是匹配，由附参的高位标记。

123     !{}(~,~)    整数值范围匹配
        // 目标值在范围之内则匹配，否则失败。
        // 附参1：下边界值，包含。
        // 附参2：上边界值，不包含。
        // 例：
        // !{0, 1024} 限定目标值：0 ≦ n < 1024
        // 注：
        // 暂不支持大整数（BigInt）的范围测试。

124     !{}(8,8,4)  浮点数值范围匹配
        // 目标值在范围之内则匹配，否则失败。
        // 附参1：下边界值，包含。
        // 附参2：上边界值，不包含。
        // 附参3：相等比较误差（不超过即视为相等）。
        // 例：
        // !{0, 1.0, 0}         目标为0或小于1.0的任意浮点数。
        // !{0.1, 10, 1e-10}    目标在0.1~10之间，下边界相等误差不超过1e-10。
        //
        // 设计：
        // 仅用4字节的浮点数表达误差，最小值：1.4013e-45。

125     RE{/.../gG}(1,1)    正则查找
        // 对文本或字节序列目标执行正则表达式匹配。
        // 附参1：查找方式（g|G|s）。
        // 附参2：正则式内容长度（<256）。
        // 附参值：
        // g：查找所有，但仅限于完整匹配（re.FindAll）。
        // G：查找所有，包括捕获组（re.FindAllSubmatch）。
        // s：查找首个匹配，包括捕获组（re.FindSubmatch）。
        // 提示：
        // 匹配的结果可由下面的 & 指令获取。
        // 注意与值指令里的正则式创建指令的不同（/.../）。
        // 例：
        // RE{/(?i)[a-z]+/s}    查找首个单词，结果为一个单成员切片
        // RE{/(?i)[a-z]+/g}    查找全部单词，结果为一个全匹配的切片

126     &(1)        正则查找取值
        // 配合上面的 RE{/.../} 指令使用，获取其匹配值成员。
        // 附参：取值序位（<256）。
        // 说明：
        // - 这是 MODEL{} 内除 #(1) 之外的另一个取值指令（共2个）。
        // - 应当紧随其属主指令 RE{/.../} 使用，但在下一个RE{}之前，可以多次取值。
        // - 如果目标没有匹配或序位超出结果集，取值为nil。
        // 例：
        // RE{/(?i)[a-z]+/s} &[0]       取匹配结果中的首个成员
        // RE{/Ver-(\d+)/s} &[1]        取首个子表达式的匹配项（主版本号）
        // RE{/(?i)[a-z]+/g} &[3] &[1]  取全局匹配的第四个和第二个结果
        // RE{/(?i)[a-z]+/}
        //
        // 设计：
        // 最多支持256个匹配结果取值，更多的匹配将无法取到。
        // 这对栈脚本来说，可能已经足够。

127     ...         指令段任意通配
        // 匹配任意连续指令序列（含零长度）。
        // - 各层级独立，块指令视为单一实体。
        // - 非贪婪模式：最小化完整匹配。
        // 例：
        // 目标脚本：
        //      SYS_TIME{Stamp} {<expireTime>} GT
        //      @TOP PRINT          // 1
        //      IF{
        //          @POP NIL
        //      }
        //      TRUE
        //      IF{
        //          "Hello"         // 2
        //          @TOP PRINT      // A
        //      }
        //      "Done!"
        //      @TOP PRINT          // B
        //      @POPS[] NOP         // End
        // 模型1：
        // MODEL{
        //      SYS_TIME{Stamp} {<expireTime>} GT
        //      ...                 // 1 => TRUE
        //      IF{
        //          ...             // 2 "Hello"
        //          @TOP PRINT      // A
        //      }
        //      "Done!"
        //      @TOP PRINT          // B
        //      @POPS NOP           // 必须抵达终点，完整结束
        // }
        //
        // 模型2：
        // MODEL{
        //      SYS_TIME{Stamp} {<expireTime>} GT
        //      ...
        //      IF{?}               // 匹配第一个IF（非贪婪）
        //      ...                 // 剩余匹配，必需！
        // }
        // 注意：
        // 最后的...是必须的，这是匹配完整性要求（匹配到脚本结束）。
        //
        // 模型3：
        // MODEL{
        //      SYS_TIME{Stamp} {<expireTime>} GT
        //      ...
        //      IF{?}           // 匹配第二个IF，
        //      "Done!"         // 因为此处与IF共为一个约束
        //      ...             // 抵达末尾
        // }
        //
        // 警告：
        // 本指令可能较为消耗资源！如果可能，尽量使用明确的段通配。
```


## 小结：模式匹配的方式

- **位置匹配**：模式指令与目标指令按位置对比匹配。
- **指令匹配**：指令相同即为匹配。如果指令为值指令，则也隐含了类型逻辑。
- **附参匹配**：在指令匹配的前提下，附参参与匹配。
- **数据匹配**：在指令匹配的前提下，指令关联的数据也参与匹配。
- **类型匹配**：对目标的数据类型进行匹配，值任意。
- **范围限定**：对整数和浮点数按值的范围匹配。
- **正则匹配**：`RE{/../}` 可对文本和字节序列进行匹配测试和取值。
- **片段匹配**：连续的指令片段的匹配或通配（`_(1)`, `...`）。
