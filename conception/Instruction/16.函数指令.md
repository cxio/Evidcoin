# 函数指令

在语言基础性逻辑之外，看着应该像函数的指令。包含命名前缀（`FN_`），与基础性指令有所区分。

大部分函数指令没有附参，由动态的实参提供信息输入。


## 定义

本函数集包含两个部分：*基础函数集*和*基础函数扩展*。

指令码区间：`[170-209]`，40个。


### 基础函数集

数量不多的一些常用的基础性函数。

> **注：**
> 这里的书写已略作调整，按函数定义的形式表达。实参可从括号内的声明体现出来。

```go
码值    函数名（参数序列） => 返回值类型
-----------------------------------------------------------
170     FN_BASE58( data Bytes|String ) => String|Bytes
        // 将目标字节序列为编码为 Base58 字符串，或反向解码。
        // 实参：字节序列或字符串。
        // 返回值：字符串或字节序列。
        // 提示：
        // 执行解码或编码，视实参类型而定。

171     FN_BASE32( data Bytes|String ) => String|Bytes
        // 将目标字节序列编码为 Base32 字符串，或反向解码。
        // 实参：字节序列或字符串。
        // 返回值：字符串或字节序列。
        // 规范：
        // RFC4648：大写 + 234567。
        // 提示：
        // 编码或解码时实参类型而定，字符串没有填充字符。

172     FN_BASE64( data Bytes|String ) => String|Bytes
        // 将目标字节序列编码为 Base64 字符串，或反向解码。
        // 实参：字节序列或字符串。
        // 返回值：字符串或字节序列。
        // 提示：
        // 编码或解码由实参类型自动决定。
        // 无填充字符，增补字符采用URL友好类型（-_）。

173     FN_ADDRESS( pbHash Bytes, prefix String ) => String
        // 将公钥哈希编码为账户地址（Base32:[4-9A-Z]）。
        // 实参1：公钥哈希。
        // 实参2：识别前缀。
        // 返回值：账户地址（字符串）。
        // 提示：
        // 文本形式的账户地址主要用于UI展示和识别。
        // 与简单的BASE32不同，这里包含了前缀组合以及可验证性。
        // 编码：
        // 0. 公钥哈希添加识别前缀：[前缀][公钥哈希]。
        // 1. 对结果执行2次哈希运算，取末尾4字节为校验码。
        // 2. 公钥哈希附上校验码：[公钥哈希][校验码]。
        // 3. 将结果编码为文本，附上前缀：[前缀][编码文本] >> 账户地址
        //
        // 校验：
        // 0. 分离识别前缀（长度已知）和编码文本。
        // 1. 将编码文本解码为字节序列并切分：[公钥哈希][校验码1]。
        // 2. 公钥哈希前置识别前缀：[前缀][公钥哈希]，
        // 3. 对结果执行2次哈希运算，取末尾4字节为校验码2。
        // 4. 两个校验码对比，相同即为合法。
        //
        // 参考：
        // 文本形式的账户地址仅用于人类可读展示，
        // 以及当用户构造交易解码地址时，验证输入的的地址是否合法。

174     FN_PUBHASH( data Bytes|String, ?pfsize int ) => Bytes
        // 创建单签名公钥哈希，或解码账户地址。
        // 实参1：公钥或账户地址。
        // 实参2：地址前缀长度，可选。
        // 返回值：公钥哈希。
        // 提示：
        // - 是创建还是解码地址，由实参的类型判断，
        //   如果是新创建，前缀长度参数无意义。
        // - 当为解码地址时，并不能区分结果是属于单签名还是多签名。
        //   此为上面 FN_ADDRESS 的逆行为。

175     FN_MPUBHASH( pubHash []Bytes, m, n int ) => Bytes
        // 创建多重签名的总公钥哈希。
        // 实参1：所有参与者的公钥哈希。
        // 实参2：m/N 配比中的 m。
        // 实参3：m/N 配比中的 N（m ≤ N）。
        // 返回值：复合公钥哈希。
        // 提示：
        // 与上面的 FN_PUBHASH 不同，这里仅有创建行为。
        // 且专门针对多重签名的地址。

176     FN_CHECKSIG( flag byte, sig, pubKey Bytes ) => Bool
        // 单签名验证。
        // 实参1：授权标识。
        // 实参2：签名数据。
        // 实参3：签名用公钥。
        // 返回值：成功与否。

177     FN_MCHECKSIG( flag byte, sigs, pubKeys, pubHashs []Bytes ) => Bool
        // 多重签名验证。
        // 实参1：授权标识。
        // 实参2：签名数据集。
        // 实参3：签名公钥集。与实参2成员一一对应。
        // 实参4：剩余公钥哈希集。
        // 返回值：成功与否。
        // 注记：
        // []Bytes类型在数据栈中并不存在，实际上为 []any。

178     FN_HASH224(1)( data Bytes ) => Bytes
        // 对实参数据执行哈希运算，224位长。
        // 附参：算法标识（sha3|sha2|blake2），默认 sha3。
        // 实参：任意字节序列。
        // 返回值：字节序列（28字节）。
        // 设计：
        // 支持算法标识可能是一个必要的机制，更灵活。

179     FN_HASH256(1)( data Bytes ) => Bytes
        // 256位哈希运算。
        // 附参：算法标识（sha3|sha2|blake2），默认 sha3。
        // 实参：任意字节序列。
        // 返回值：字节序列（32字节）。
        // 例：
        // DATA{...} FN_HASH256{sha3}   // 采用 sha3.Sum256（FIPS-202）
        // DATA{...} FN_HASH256         // 同上，默认算法
        //
        // 参考：
        // 这里的 blake2 实为 BLAKE2b 算法。
        // 在安全性上，BLAKE2b 比 SHA2 好，在 64位 x86 和 ARM 架构上也比 SHA2/SHA3 快。

180     FN_HASH384(1)( data Bytes ) => Bytes
        // 384位哈希运算。
        // 附参：算法标识（sha3|sha2|blake2），默认 sha3。
        // 实参：任意字节序列。
        // 返回值：字节序列（48字节）。

181     FN_HASH512(1)( data Bytes ) => Bytes
        // 512位哈希运算。
        // 附参：算法标识（sha3|sha2|blake2），默认 sha3。
        // 实参：任意字节序列。
        // 返回值：字节序列（64字节）。

182-207 （未用）

208     FN_PRINTF( fmt string, val ...any ) => nil
        // 向控制台打印消息，即 fmt.Printf。
        // 实参1：格式字符串。
        // 实参n：不定数量目标变量。
        // 提示：
        // 注意与标准打印指令 PRINT 的不同。
```


### 基础函数扩展

```go
码值    指令字          说明
-----------------------------------------------------------
209     FN_X(1){}       扩展函数引用
        // 调用目标位置的扩展函数。
        // 附参：目标索引。
        // 实参：……
        // 实参视具体情况而不同，由目标指令及其配置决定。
        // 说明：
        // 基础扩展仅支持1字节空间，最多可扩展256个函数指令。
        // 如果需要更多功能性函数，可使用正式的扩展指令 EX_FN（见后）。
        //
        // 友好：
        // 花括号内可用目标名称书写。
```
