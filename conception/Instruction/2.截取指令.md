# 截取指令

用于拦截指令的返回值、或从目标位置取值、或赋值到特定区域。

这是栈脚本的基础功能指令，指令名用特殊符号表达，以方便与目标指令结合。作为一种友好，符号与后面的目标指令无需用空格分离。

本系列指令功能独特，取值时直接放入实参区（而非自动入栈）。


## 定义

指令码区间：`[20-24]`，5个。

```go
码值    指令字      说明
-----------------------------------------------------------
20      @           实参捕获
        // 拦截后一个指令的返回值，放入实参区。
        // 例：
        // @PEEKS[2]    获取栈底2个值展开到实参区。
        // @{1234}      将整数 1234 放入实参区（本来会自动入栈）。

21      ~           实参直取
        // 指示后一个指令的实参将从数据栈直接提取（跳过实参区）。
        // 这是一种主动的取值渠道切换。
        // 如果目标指令同时也前置了拦截（@|$），则本指令应当在拦截指令之后，目标指令之前。
        // 例：
        // ~EQUAL   直接取栈顶两个值作相等比较。
        // @~EQUAL  同上取栈顶两个值比较，结果放入实参区。
        // $~EQUAL  同上，但结果放入局部域。
        //
        // 设计：
        // 支持跳过实参空间直取，可为数据的腾挪增添更多灵活。

22      $           局域存值
        // 截取后一个指令的返回值，添加到当前局部域中。
        // 局部域是一个当前块的静态堆叠空间（只添加），容量128。
        // 例：
        // $TOP         引用栈顶项添加到当前局部域（引用复制）。
        // $POPS[3]     弹出栈顶3项展开到局部域中（添加了3项）。
        // ${100}       将值 100 直接添加到局部域。
        // $SHIFT[3]    取出栈顶3项打包为一个切片，添加到局部域（共1项）。
        // 注意：
        // 局部域是语法块私有的。
        // 不同局部域之间无法互通，只有同级指令才共享其局部域。

23      $(1)        局域取值（引用）
        // 引用局部域的值，放入实参区。
        // 需与上面的存值指令配合使用。
        // 附参：成员位置下标。
        // 下标范围：[-128, 127]，支持负数从末尾算起。
        // 例：
        // $[0]     引用第1个添加进局部域中的值。
        // $[-1]    引用最后一个添加到局部的值。
        //
        // 实现：
        // 可能支持用存值时所截取指令的名称来引用（有重名覆盖问题）。
        // 如：
        // ${POP}   引用 $POP 存入的值。

24      $X(1)       循环域变量引用
        // 用于循环体内，可跨语法块层级（与局域不同）。
        // 引用的变量值依然放入实参区，这与 @ 和 $[n] 的行为一致。
        // 附参：变量标识 [0-3]。
        // 用名称引用：
        // $Value       当前条目值 [0]
        // $Index|$Key  当前循环键（整数下标或字符串键） [1]
        // $Slice|$Dict 目标集本身 [2]
        // $Size        集合大小（成员数） [3]
        // 注：
        // 名称大小写敏感，前置$字符。
        // 提示：
        // 循环目标包括切片（$Slice）和字典（$Dict），
        // 前者的键为数值（$Index），后者的键为字符串（$Key）。
```

> **小结：**
> 除了局域存值（`$`）和实参直取（`~`）外，另3个指令都为取值。
