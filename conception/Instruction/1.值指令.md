# 值指令

作为一个具体的值存在，直接自动入栈。


## 定义

指令码区间：`[0-19]`，20个。

```go
码值    指令字      说明
-----------------------------------------------------------
0       NIL         空：nil
        // 通用的nil项，表示无值。
        // 指令码值本身表达该值。

// 以下为基本类型。

1       TRUE        真值：true
2       FALSE       假值：false
        // 类型：Bool
        // 指令码值本身就表达该值，运行时为true|false。
        // 即：
        // - 码值1 => true
        // - 码值2 => false
        //
        // 提示：
        // 交易中的脚本为编译后的指令码“值序列”。

// 以下指令包含附参或其关联数据。

3       ''          字节：byte [0, 255]
        // 类型：Byte
        // 数据：占用一个字节的值（uint8）。
        // 即uint8的别名，可用于小正整数计算。
        // 例：
        // 'A'      单引号包围字符（A，值65）。
        // '\n'     支持转义表达（换行符，值10）。
        // '\x41'   支持16进制转义（A）。
        //
        // 提示：
        // `A` 编译后的值序列为：0x03 0x41
        // 其中：
        // 0x03 表示字节类型指令码，0x41 表示字符 'A' 的值。

4       ''          符文：rune [0, 0x10FFFF]
        // 类型：Rune
        // 数据：即Unicode码点值，4字节长（uint32）。
        // 例：
        // '嗨'     单引号包围的Unicode字符。
        // '\u4e16' 支持'\uhhhh'或'\Uhhhhhhhh'转义（世）。
        // '\u0041' 字符A用Rune类型存储。

5       {}          整数：int64 [-1<<63, 1<<63 - 1]
        // 类型：Int
        // 数据：变长整数值（varint），字节数可变。
        // 例：
        // {12345}  整数值 12345
        // {123_45} 同上，支持单下划线友好分割。
        //
        // 设计：
        // 不采用直接的数字而是用一个花括号来包围，
        // 是希望指令有明显的边界，体现栈脚本「指令序列」的视觉一致性。

6       {}(1)       大整数：big.Int
        // 类型：BigInt
        // 附参：1字节，指定后续大整数值占用的字节数。
        // 数据：大整数值（big.Int）。
        // 即Go语言中 math/big 包里的Int类型，但长度受限（<256字节）。
        // 例：
        // {0x8000ffff_8000ffff_8001}
        // 超出了int64的表示范围，即被解析为大整数。
        // 注：
        // 通常用十六进制书写，依然支持下划线友好分隔。

7       {}          浮点数：float64
        // 类型：Float
        // 数据：浮点数值（float64），固定8字节长。
        // 例：
        // {3.14159}    浮点数值 3.14159
        // {2.16e10}    支持科学计数法。
        // {123.}       浮点数值 123.0，注意末尾的点。
        // 注：
        // 需包含小数点以与整数区分，支持科学记数法。

8       ""(1)       短字符串：string [0, 256)
9       ""(2)       长字符串：string [256, 65536)
        // 类型：String
        // 附参：字符串的字节数。
        // 数据：字符串内容（UTF-8编码）。
        // 依长度自动决定使用哪个指令。
        // 支持字符串内的转义字符（同Go语言）。
        // 例：
        // "Hello world"    双引号包围的简单字符串。
        // "Hello\nWorld"   支持转义表达（同Go语言）。
        // `Hello\nworld`    反引号包含，字符串原始表达，无转义（同Go）。
        // 注：
        // 附参的大小会自动计算，不需要人为指定。

// 以下为复杂值类型。

10      {...}(~)    值集：[...]
        // 创建值集。
        // 即通过 {1, 2, 3} 形式创建的序列。
        // 附参：值成员序列的总字节长度。
        // 数据：值序列，遵循各自的指令码格式。
        // 支持的类型：
        // - Bool
        // - Byte
        // - Rune
        // - Int
        // - *BigInt
        // - Float
        // - String
        // 注意：
        // 值序列需要类型一致，或至少是可提升的，
        // 运行时会将所有的值成员统一为最大的类型：
        // - Byte => Rune => Int => BigInt
        // - Byte => Rune => Int => Float
        // 其中：
        // 浮点数和字符串之上没有更大的类型，因此不可再提升。
        // 例：
        // {}               // 错误，缺乏类型表达
        // {TRUE, FALSE}    // 一个布尔值集 []Bool
        // {'A', 'B'}       // 一个字母集 ['A', 'B']，即 []Byte
        // {'你', '好'}     // 一个符文集 ['你', '好']，即 []Rune
        // {2, 4, 8}        // 创建一个整数值集
        // {100, }          // 一个单成员值集：[100]，注意跟随的逗号。
        // {3.14, 5}        // 一个浮点数集 []Float
        // {0x8000ffff_8000ffff_8001, 0xffff} // 一个大整数集 []*big.Int
        // {"Hello", "World"}   // 一个字符串集 []String
        //
        // 设计：
        // 值类型的提升在运行时发生而不是编译为指令码时。
        // 这是值指令里的“特例”，不是独立的类型，是一个便捷构造方式。

11      DATA{}(1)   小数据：[]byte [0, 256)
12      DATA{}(2)   大数据：[]byte [256, 65536)
        // 类型：Bytes
        // 附参：数据的长度（字节数）。
        // 数据：十六进制表达（无前置0x），数据长度自动决定使用哪个指令。
        // 支持明确指定长度的写法。
        // 例：
        // DATA{46af3fb4}       自动计算为4字节数据。
        // DATA[8]{46af3fb4}    明确8字节长，后续空位以0填充。

13      /.../(1)    正则表达式：RE2
        // 类型：RegExp
        // 附参：内容字节数（<256）。
        // 数据：正则表达式内容（UTF-8编码），书写在双斜线内。
        // 注：附参值自动计算得出。
        // RE2: github.com/google/re2/wiki/Syntax
        // 例：
        // /(?i)[a-z0-9]+/  匹配ASCII字母和数字，忽略大小写
        // /(?i)Zip-(\d+)/  忽略大小写，包含一个子匹配（捕获组）
        //
        // 设计：
        // 仅支持最长255字节的表达式，应已足够。

14      DATE{}     时间对象
        // 类型：Time
        // 数据：UNIX时间戳（毫秒数），有符号变长整数。
        // 花括号内书写时间表达式（RFC3339）。
        // 也支持附参形式表达时间戳（方括号内的UNIX时间戳毫秒数）。
        // 例：
        // DATE{2020-11-24T15:04:05Z}
        // DATE{2020-11-24T15:04:05.456+08:00}
        // DATE[1606227845000]  UNIX时间戳（毫秒数）
        // 注：
        // 仅支持RFC3339标准格式（更多参考 MO_TIME）。

15-16   （未用）


17      CODE{}(~)   代码/指令序列
        // 类型：Script
        // 附参：所包含序列的长度（自动计算）。
        // 数据：实际的指令序列，已编译（指令码+附参+关联数据）。
        // 例：
        // CODE{
        //      TOP FN_HASH256 DATA{<hashResult>} EQUAL PASS
        // }
        // 这是一段哈希屏障的验证序列。
        //
        // 安全性：
        // 序列中的指令仅为字面值数据，不会被执行。
        // 可用于配合EVAL使用，或为第三方扩展提供某种执行逻辑。

18      SCRIPT(~,64,~)  脚本引用
        // 类型：Script
        // 附参1：交易年度（按交易时间戳计算），变长整数。
        // 附参2：交易ID，64字节。
        // 附参3：脚本所在输出项序位，变长整数。
        // 引入交易的输出脚本。
        // 例：
        //      SCRIPT[2025, 0xab93cf..., 0] FN_HASH256 ...
        // 引入2025年 0xab93cf...交易的第一项输出脚本入栈，
        // 计算脚本的哈希……
        //
        // 提示：
        // 可用于引用存证交易的识别脚本。

19      VALUE{}(1)      获取某值
        // 类型：Any
        // 通用的取值指令。
        // 附参：值索引。
        // 可用于某些环境信息（与ENV有重叠）或其它信息的获取。
        // 通常使用花括号引用值名称的方式，例如 VALUE{ValueName}。
        // 也支持方括号引用值索引（附参用法）。
        //
        // 设计：
        // 为了在解锁区使用某些必要的值而单列出来。
        // 它是通用的，也可能用于未来（量子计算）需要的前置求值。
```
