# 流程控制

控制脚本的执行路径。指令的子语句块即为关联数据。

> **注**：此系列指令无返回值。


## 定义

指令码区间：`[57-66]`，10个。

```go
码值    指令字      说明
-----------------------------------------------------------
57      IF{}(~)     如果
        // 如果实参为true，则子语句块执行。
        // 附参：子语句块长度。
        // 实参：布尔值。
        // 例：
        // IF {
        //      @POP PRINT  // 提取栈顶项并打印
        // }
        // 说明：
        // IF的条件由实参表达，在指令之前已经就绪。
        // 同一层级中，后来的IF会覆盖先前的IF（的状态）。

58      ELSE{}(~)   如果不满足
        // 检查本层级IF状态，如果IF为假则执行。
        // 附参：子语句块长度。
        // 实参：无。
        // 提示：
        // ELSE只匹配最近的一个IF。
        // IF和ELSE并不需要紧邻，中间可有其它指令序列。
        // 例：
        // IF {
        //      ...
        // }
        // @POP PRINT   // 不影响 IF/ELSE 的关系
        // ELSE {
        //      ...
        // }
        // 例：
        // IF {...}
        // IF {...}     // 覆盖前一个IF的状态
        // ELSE {       // 匹配第二个IF
        //      ...
        // }

59      SWITCH{}(~) 分支选择区
        // 创建 switch 语法块。
        // 附参：语句块长度。
        // 实参1：标的值。将与CASE分支值对比，任意可比较类型。
        // 实参2：CASE分支值列表，长度应与CASE数量相同。
        // 提示：
        // 若标的值为true，可模拟 if/elseif/else 的逻辑。
        //
        // 设计：
        // 一次性给出对比目标和全部分支的候选值序列，
        // 可以使得CASE分支简洁清晰。

60      CASE{}(~)   条件分支
        // 附参：子语句块长度。
        // 实参：无。
        // 实参已被预先提取，按位置顺序对比：
        // - 真：执行子语句块。
        // - 假：跳过子语句块。
        // 说明：
        // 只有最先匹配的CASE块会被执行，之后SWITCH结束。
        // CASE块中也可以用BREAK主动退出。
        // 例：
        // {10}             // SWITCH 标的值
        // {3, 10, 20}      // CASE 分支对比值序列
        // SWITCH {
        //      CASE{       // [0] 与标的值比较，相等则执行
        //          ...
        //      }
        //      CASE{...}   // [1] 与标的值比较……此例中相等、执行
        //      CASE{...}   // 不会到此，上一CASE已经执行并退出
        //      DEFAULT{    // 默认分支：
        //          ...     // 所有CASE比较为假时执行
        //      }
        // }
        // 提示：
        // CASE之间实际上也可以有其它指令，但不常用。

61      DEFAULT{}(~)    默认分支
        // 所有CASE比较为假时执行，作为最后一个语句块，可选。
        // 附参：子语句块长度。
        // 实参：无。

62      EACH{}(~)   迭代（有限循环）
        // 对集合成员逐一迭代、执行子语句块。
        // 与集合指令中的 MAP/FILTER 不同，这里没有私有数据栈逻辑。
        // 附参：子语句块长度。
        // 实参：目标集（切片|字典）。
        // 循环变量：
        // 参考前截取指令 $X
        // - $Value
        // - $Index|$Key
        // - $Slice|$Dict
        // - $Size
        // 注：
        // 如果要中断当前循环，应执行 BREAK 而不是 RETURN。
        // 例：
        // {1, 3, 5}
        // EACH{
        //      ($Value * 10)   // 表达式运算，结果入栈
        // }
        // @SHIFT[3] PRINT      // [10, 30, 50]
        //
        // 例：
        // {10, 20, 30}
        // EACH {
        //      $Value PUSH     // 入栈当前条目值
        // }
        // 这相当于将一个整数序列展开入栈，
        // 即：
        // {10, 20, 30} SPREAD  // {10} {20} {30}

63      CONTINUE    继续
        // 终止当前EACH{}循环并开始下一迭代。
        // 实参：布尔值，可选。
        // 如果实参有值，则真值执行。否则直接执行。

64      BREAK       中断
        // 退出EACH循环或SWITCH分支选择区。
        // 实参：布尔值，可选。
        // 如果实参有值，则真值执行。否则直接执行。
        // 例：
        // {1, 3, 30, 5}        // 迭代目标集
        // EACH{
        //      $Value {10} GT  // 入栈当前值和10，比较两者
        //      @POP BREAK      // 取比较结果，真时退出
        //      @$Index PRINT   // 打印当前序号
        // }
        // @"Done!" PRINT
        //
        // 结果：
        // 0        // $Value = 1
        // 1        // $Value = 3
        // Done!

65      （未用）

66      BLOCK{}(~)  块域
        // 创建一个子块。
        // 主要是为了创建局部域或分离出一个指令序列的范围，
        // 比如规划局部变量使用，或用 SOURCE 提取脚本的局部片段等。
        // 附参：子语句块长度。
        // 实参：无。
        // 例：
        // BLOCK{
        //      ......      // 正常执行
        //      SOURCE      // 提取当前块指令序列（含SOURCE）入栈
        // }
        // @POP PRINT       // 打印 BLOCK 区隔出的指令序列
        //
        // 提示：
        // 如果不是因为需要，在脚本中使用和不使用BLOCK没有区别。
```


## 关于循环

本脚本系统中没有无限循环，但用EACH来表达类似的逻辑。作为循环逻辑，块内支持 `BREAK` 而非 `RETURN`。
