# AI存疑与用户问答

> **注：**
> 在 opencode TUI 界面下，AI Agent（Claude Opus 4.6）作为主体身份。

## 理解与问题

我已仔细阅读了 Evidcoin 项目的设计构想。这是一个设计精良的区块链系统，采用历史证明（PoH）共识机制，核心理念是将区块链作为通用的信用载体。以下是我在理解过程中的一些疑问：

### 第一批问题（共识与结构相关）

**问题 1：关于 UTXO 指纹的计算**

在「1.共识-历史证明（PoH）.md」中提到 UTXO 指纹用于参与铸凭哈希的计算，并且在「改进」部分提到取 `-24` 号区块的 UTXO 指纹。

请问：
- UTXO 指纹具体是如何计算的？是对整个 UTXO 集合状态的哈希，还是仅针对该区块产生的 UTXO 变化？
- 如果是整个 UTXO 集的状态哈希，这个集合可能非常庞大，是否有增量计算或压缩的机制？

**问题 2：关于区块头中的「校验根」（CheckRoot）**

在「blockchain.md」的区块头结构中，`CheckRoot` 被描述为「由交易哈希树根、UTXO指纹及签名合并计算」。

请问：
- 这里的「签名」指的是什么签名？是铸造者的签名，还是某种聚合签名？
- 「校验根」的完整计算公式是怎样的？

**问题 3：关于新币的 25 区块确认限制**

文档提到「新币需要经历25个区块之后才能兑现」，这个限制如何与分叉竞争的 25 区块规则协调？

- 如果在第 24 区块时发现分叉并最终切换到另一条链，那些在原链上铸造的新币如何处理？
- 铸币交易（Coinbase）是否也遵循这个 25 区块确认规则，还是有特殊处理？

---

请您解答这些问题后，我再继续深入理解并提出后续问题（如有），然后开始撰写提案。

---

## User

1. UTXO 指纹的设计刚好在 `附.组队校验.md` 文档里，看来还是需要你也读一下这个文档。这个指纹确实是针对整个区块链（至当前所有的UTXO），但是有分级计算设计。
2. 「签名」是铸造者对这个 `CheckRoot` 的签名。CheckRoot 的概念也在组队校验的文档里，是区块的全部交易的ID汇总计算的哈希校验树（类默克尔树）树根和UTXO指纹的合并后计算的哈希。
3. 无需协调。只有当新币被花费的时候，才需要验证它是否已经是25个区块之前（更古老）的币。如果分叉后切换了主链，被放弃的原链上那一段区块上的交易会被回收

---

## Assistant (Build · claude-opus-4.6 · 16.1s)

好的，现在我对整个项目有了全面的理解。之前的三个问题都已经清楚了，让我再确认几个新的疑问。

---

## 第二批问题

**问题 1：关于区块头中缺少时间戳字段**

在 `blockchain.md` 的区块头结构中，没有显式的时间戳字段。文档说「每一个区块的时间戳都通过高度和时间间隔计算出来」。这意味着：

- 创始区块的时间戳需要被所有节点预先知道（硬编码）？
- 区块头中确实不需要存储时间戳字段，因为 `Timestamp = GenesisTimestamp + Height * 6min`，对吗？

**问题 2：关于公钥哈希的长度**

在交易结构中，输出项的地址字段显示为 `[48]byte`（48字节，384位）。但其他地方提到系统默认使用 SHA-512（64字节）。

请问：公钥哈希的实际长度是多少？是用 SHA-512 后截取前 48 字节，还是使用 SHA-384 得到 48 字节？

**问题 3：关于交易费 50% 销毁的计算**

在激励机制中提到「区块的最终交易费总额只回收 50%，即 50% 的交易费被销毁」。

请确认：Coinbase 交易中的收益总额 = 铸币 + 交易费总额 × 50% + 兑奖截留，对吗？被销毁的 50% 交易费不会出现在 Coinbase 的任何输出中？

---

## User

1. 是的，创始区块的信息在任何时候和地方都是已知的，你理解得对！
2. 公钥哈希考虑到会被花费，时间维度上不是永久，所以设计短了一些（48字节），用 SHA-384 计算。
3. 是的。只是交易费的 50% 被销毁，这在节点验证交易费的情况时计算核实，无需保存在 Coinbase 中。

---

## Assistant (Build · claude-opus-4.6 · 19.8s)

好的，这些都清楚了。让我再提最后一批小问题，然后就可以开始撰写提案了。

---

## 第三批问题

**问题 1：关于凭信的「转移计次」和「有效期」到期后的处理**

文档中说凭信到期后会从 UTXO 集中移除，"但依然在链上，类似于下面的存证"。

请确认：到期的凭信从 UTXO 中移除的时机是什么？是每个区块构建时检查所有凭信是否到期（主动扫描），还是在某笔交易试图引用它时才判定（被动检查）？如果是主动扫描，大量凭信的情况下是否有性能考虑？

**问题 2：关于脚本中 GOTO 跳转到外部交易的执行环境**

脚本的 `GOTO` 指令可以跳转到另一笔交易的输出脚本（介管脚本）。文档提到跳转到的脚本「在一个独立子环境中执行（继承部分调用环境）」。

请问：跳转后的脚本执行结果如何影响原脚本？是：
- (a) 子环境的 PASS/失败结果会传递回调用者？
- (b) 子环境的数据栈状态会合并回主环境？
- (c) 还是两者都有？

**问题 3：关于解锁数据中签名的「剥离」设计**

系统指令 `SYS_CHKPASS` 的注释中提到「让解锁脚本中的签名数据剥离，不参与交易ID计算，方便后期移除」。

请确认：这是否意味着交易ID的计算（即交易头的哈希）完全不包含解锁脚本/签名数据？签名数据存储在交易的哪个位置——是与交易体分开存储的独立区域？

---

## User

1. 在凭信转移验证时，就会检查是否到期，如果到期，会标记该输出项，如果整笔交易（输入来源交易）的输出项都花费完了，则移除其在UTXO中的条目。基本上属于被动的逻辑。
2. (a) 子环境的 PASS 成功/失败 会写回顶层调用者（子脚本中也可能有GOTO）。(b) 子环境的数据栈是临时的，退出即丢弃。
3. 解锁部分包含签名数据和其它可能需要的脚本（合约不只是签名验证）。只有签名数据可以丢弃，因为签名验证在交易入块时已经执行，后期区块链的安全仅依赖哈希保证——双链耦合（前一区块ID的链式结构和UTXO指纹的链式关系），安全性应该足够。因此签名数据是即时传递和验证，临时存储。

---

## Assistant (Build · claude-opus-4.6 · 12.6s)

感谢您的耐心解答！现在我对整个项目的设计有了充分的理解。让我开始撰写提案。
